Thank you for confirming to proceed with the solution for the second task. Below is a detailed, step-by-step solution for **Task 2: Deploying Microservices in Kubernetes with CI/CD and Monitoring**, formatted in an `<xaiArtifact>` tag. The solution is designed to be clear, comprehensive, and tailored for the IT-Планета 2025 competition, addressing potential errors and providing actionable steps to ensure success.

---

## Task 2: Deploying Microservices in Kubernetes with CI/CD and Monitoring

### Description
Deploy a microservices-based application in a Kubernetes cluster, integrate it with a CI/CD pipeline, and set up performance monitoring.

### Objectives
- Create a local Kubernetes cluster (e.g., using Minikube or kind).
- Deploy an application consisting of three microservices: frontend (React), backend (Node.js), and database (MongoDB) using Kubernetes Deployments and Services.
- Configure Ingress for HTTP access to the frontend.
- Implement a CI/CD pipeline (using GitLab CI or Jenkins) for automated Docker image building and deployment to Kubernetes upon repository commits.
- Set up Prometheus and Grafana for monitoring application and cluster metrics.

### Tools
Kubernetes, Docker, Git, GitLab CI/Jenkins, Prometheus, Grafana.

### Expected Result
A fully functional application running in Kubernetes with automated deployment and monitoring, accessible via Ingress.

---

### Step-by-Step Solution

#### Step 1: Set Up the Environment
1. **Install Required Tools**:
   - **Minikube**: For creating a local Kubernetes cluster.
     ```bash
     curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
     sudo install minikube-linux-amd64 /usr/local/bin/minikube
     ```
   - **kubectl**: For interacting with Kubernetes.
     ```bash
     curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
     sudo install kubectl /usr/local/bin/kubectl
     ```
   - **Docker**: For building images.
     ```bash
     sudo apt update
     sudo apt install docker.io -y
     sudo usermod -aG docker $USER
     ```
   - **Git**: For version control.
     ```bash
     sudo apt install git -y
     ```
   - **Jenkins** (optional, if not using GitLab CI):
     ```bash
     sudo apt install openjdk-11-jdk -y
     wget https://pkg.jenkins.io/debian-stable/binary/jenkins_2.426.3_all.deb
     sudo dpkg -i jenkins_2.426.3_all.deb
     sudo apt install -f
     ```

2. **Verify Installation**:
   ```bash
   minikube version
   kubectl version --client
   docker --version
   git --version
   ```

**Possible Errors**:
- **Minikube fails to start**: Ensure virtualization is enabled (VT-x/AMD-V in BIOS) and Docker is running.
- **Permission issues with Docker**: Log out and back in after adding the user to the Docker group or restart the session.

---

#### Step 2: Create a Local Kubernetes Cluster
1. **Start Minikube**:
   ```bash
   minikube start --driver=docker
   ```
   This creates a single-node Kubernetes cluster.

2. **Enable Ingress Controller**:
   ```bash
   minikube addons enable ingress
   ```

3. **Verify Cluster**:
   ```bash
   kubectl cluster-info
   kubectl get nodes
   ```

**Possible Errors**:
- **Ingress addon not enabled**: Verify with `minikube addons list` and enable if necessary.
- **Cluster not reachable**: Check Docker status (`systemctl status docker`) and Minikube logs (`minikube logs`).

---

#### Step 3: Set Up the Microservices Application
1. **Create a Git Repository**:
   ```bash
   mkdir microservices-app
   cd microservices-app
   git init
   ```

2. **Frontend (React)**:
   Create a simple React app in `frontend/`:
   ```bash
   mkdir frontend
   cd frontend
   npx create-react-app .
   ```
   Create a `Dockerfile`:
```Dockerfile
FROM node:16
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build
CMD ["npm", "start"]
```

3. **Backend (Node.js)**:
   Create a simple Node.js API in `backend/`:
   ```bash
   mkdir ../backend
   cd ../backend
   npm init -y
   npm install express mongodb
   ```
   Create `index.js`:
```javascript
const express = require('express');
const { MongoClient } = require('mongodb');
const app = express();
const port = 3000;

app.use(express.json());

const url = 'mongodb://mongodb:27017';
const dbName = 'mydb';

app.get('/data', async (req, res) => {
  let client;
  try {
    client = await MongoClient.connect(url);
    const db = client.db(dbName);
    const data = await db.collection('items').find().toArray();
    res.json(data);
  } catch (err) {
    res.status(500).send(err.message);
  } finally {
    if (client) client.close();
  }
});

app.listen(port, () => console.log(`Backend running on port ${port}`));
```
   Create a `Dockerfile`:
```Dockerfile
FROM node:16
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
CMD ["node", "index.js"]
```

4. **Database (MongoDB)**:
   MongoDB will be deployed directly via Kubernetes, so no local setup is needed.

**Possible Errors**:
- **React build fails**: Ensure Node.js version compatibility (e.g., Node 16).
- **MongoDB connection issues**: Verify the service name (`mongodb`) matches in Kubernetes.

---

#### Step 4: Create Kubernetes Manifests
1. **MongoDB Deployment and Service**:

k8s/mongodb.yaml
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mongodb
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mongodb
  template:
    metadata:
      labels:
        app: mongodb
    spec:
      containers:
      - name: mongodb
        image: mongo:latest
        ports:
        - containerPort: 27017
---
apiVersion: v1
kind: Service
metadata:
  name: mongodb
  namespace: default
spec:
  selector:
    app: mongodb
  ports:
  - protocol: TCP
    port: 27017
    targetPort: 27017
```

2. **Backend Deployment and Service**:
k8s/backend.yaml
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: default
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: my-backend:latest
        ports:
        - containerPort: 3000
---
apiVersion: v1
kind: Service
metadata:
  name: backend
  namespace: default
spec:
  selector:
    app: backend
  ports:
  - protocol: TCP
    port: 3000
    targetPort: 3000
```

3. **Frontend Deployment and Service**:
k8s/frontend.yaml
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: default
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: my-frontend:latest
        ports:
        - containerPort: 3000
---
apiVersion: v1
kind: Service
metadata:
  name: frontend
  namespace: default
spec:
  selector:
    app: frontend
  ports:
  - protocol: TCP
    port: 3000
    targetPort: 3000
```

4. **Ingress Configuration**:
k8s/ingress.yaml
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: app-ingress
  namespace: default
spec:
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend
            port:
              number: 3000
```

**Possible Errors**:
- **Image pull errors**: Ensure images are built and pushed to a registry or loaded locally (`minikube cache add`).
- **Ingress not working**: Verify the Ingress controller is running (`kubectl get pods -n ingress-nginx`).

---

#### Step 5: Set Up CI/CD Pipeline with Jenkins
1. **Start Jenkins**:
   ```bash
   systemctl start jenkins
   ```
   Access `http://192.168.1.10:8080` and use the initial admin password:
   ```bash
   cat /var/lib/jenkins/secrets/initialAdminPassword
   ```

2. **Configure Jenkins**:
   - Install plugins: Docker, Git, Kubernetes.
   - Add Docker credentials for the user `jenkins`:
     ```bash
     sudo usermod -aG docker jenkins
     systemctl restart jenkins
     ```

3. **Create a Jenkins Pipeline**:
   Create a `Jenkinsfile` in the repository root:
```groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                dir('frontend') {
                    sh 'docker build -t my-frontend:latest .'
                }
                dir('backend') {
                    sh 'docker build -t my-backend:latest .'
                }
            }
        }
        stage('Push') {
            steps {
                sh 'minikube cache add my-frontend:latest'
                sh 'minikube cache add my-backend:latest'
            }
        }
        stage('Deploy') {
            steps {
                sh 'kubectl apply -f k8s/mongodb.yaml'
                sh 'kubectl apply -f k8s/backend.yaml'
                sh 'kubectl apply -f k8s/frontend.yaml'
                sh 'kubectl apply -f k8s/ingress.yaml'
            }
        }
    }
}
```

4. **Configure Jenkins Job**:
   - Create a new Pipeline job in Jenkins.
   - Set the Git repository path (e.g., `/path/to/microservices-app`).
   - Specify the `Jenkinsfile` as the pipeline script.
   - Trigger the build manually or configure a webhook for Git commits.

**Possible Errors**:
- **Jenkins cannot access Docker**: Verify Jenkins user permissions (`ls -l /var/run/docker.sock`).
- **Pipeline fails on deploy**: Ensure `kubectl` is configured on the Jenkins node (`kubectl config view`).

---

#### Step 6: Set Up Monitoring with Prometheus and Grafana
1. **Install Prometheus**:
   Use Helm to deploy Prometheus:
   ```bash
   helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
   helm install prometheus prometheus-community/prometheus
   ```

2. **Install Grafana**:
   ```bash
   helm repo add grafana https://grafana.github.io/helm-charts
   helm install grafana grafana/grafana
   ```

3. **Access Grafana**:
   Get the admin password:
   ```bash
   kubectl get secret --namespace default grafana -o jsonpath="{.data.admin-password}" | base64 --decode
   ```
   Forward the port:
   ```bash
   kubectl port-forward svc/grafana 3000:80
   ```
   Access `http://localhost:3000` (default login: `admin`).

4. **Configure Grafana**:
   - Add Prometheus as a data source (`http://prometheus-server`).
   - Import a Kubernetes dashboard (e.g., ID 6417).

**Possible Errors**:
- **Helm not installed**: Install with `curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash`.
- **Prometheus not collecting metrics**: Verify service discovery (`kubectl get endpoints`).

---

#### Step 7: Test the Application
1. **Access the Application**:
   Get the Minikube IP:
   ```bash
   minikube ip
   ```
   Access the frontend: `http://<minikube-ip>`.

2. **Verify Monitoring**:
   Check Grafana dashboards for cluster and application metrics.

**Possible Errors**:
- **Application not accessible**: Verify Ingress rules (`kubectl describe ingress`) and service selectors.
- **Monitoring data missing**: Ensure Prometheus is scraping the correct endpoints.

---

### Recommendations
- **Offline Access**: Save Docker images (`docker save -o image.tar my-frontend:latest`), Helm charts, and manifests on a USB drive.
- **Testing**: Practice deploying the cluster and pipeline locally with time constraints.
- **Cheatsheets**: Refer to Appendix E for Kubernetes commands and Appendix D for Jenkins.


# Solution for Task 2: Deploying Microservices in Kubernetes with CI/CD and Monitoring

## Step 1: Set Up the Environment
1. **Install Required Tools**:
   - **Minikube**:
     ```bash
     curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
     sudo install minikube-linux-amd64 /usr/local/bin/minikube
     ```
   - **kubectl**:
     ```bash
     curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
     sudo install kubectl /usr/local/bin/kubectl
     ```
   - **Docker**:
     ```bash
     sudo apt update
     sudo apt install docker.io -y
     sudo usermod -aG docker $USER
     ```
   - **Git**:
     ```bash
     sudo apt install git -y
     ```
   - **Jenkins** (optional):
     ```bash
     sudo apt install openjdk-11-jdk -y
     wget https://pkg.jenkins.io/debian-stable/binary/jenkins_2.426.3_all.deb
     sudo dpkg -i jenkins_2.426.3_all.deb
     sudo apt install -f
     ```

2. **Verify Installation**:
   ```bash
   minikube version
   kubectl version --client
   docker --version
   git --version
   ```

**Possible Errors**:
- **Minikube fails to start**: Ensure virtualization is enabled (VT-x/AMD-V in BIOS) and Docker is running.
- **Permission issues with Docker**: Log out and back in after adding the user to the Docker group.

## Step 2: Create a Local Kubernetes Cluster
1. **Start Minikube**:
   ```bash
   minikube start --driver=docker
   ```

2. **Enable Ingress Controller**:
   ```bash
   minikube addons enable ingress
   ```

3. **Verify Cluster**:
   ```bash
   kubectl cluster-info
   kubectl get nodes
   ```

**Possible Errors**:
- **Ingress addon not enabled**: Verify with `minikube addons list`.
- **Cluster not reachable**: Check Docker status (`systemctl status docker`).

## Step 3: Set Up the Microservices Application
1. **Create a Git Repository**:
   ```bash
   mkdir microservices-app
   cd microservices-app
   git init
   ```

2. **Frontend (React)**:
   ```bash
   mkdir frontend
   cd frontend
   npx create-react-app .
   ```
   Create `Dockerfile`:
   ```Dockerfile
   FROM node:16
   WORKDIR /app
   COPY package*.json ./
   RUN npm install
   COPY . .
   RUN npm run build
   CMD ["npm", "start"]
   ```

3. **Backend (Node.js)**:
   ```bash
   mkdir ../backend
   cd ../backend
   npm init -y
   npm install express mongodb
   ```
   Create `index.js`:
   ```javascript
   const express = require('express');
   const { MongoClient } = require('mongodb');
   const app = express();
   const port = 3000;

   app.use(express.json());

   const url = 'mongodb://mongodb:27017';
   const dbName = 'mydb';

   app.get('/data', async (req, res) => {
     let client;
     try {
       client = await MongoClient.connect(url);
       const db = client.db(dbName);
       const data = await db.collection('items').find().toArray();
       res.json(data);
     } catch (err) {
       res.status(500).send(err.message);
     } finally {
       if (client) client.close();
     }
   });

   app.listen(port, () => console.log(`Backend running on port ${port}`));
   ```
   Create `Dockerfile`:
   ```Dockerfile
   FROM node:16
   WORKDIR /app
   COPY package*.json ./
   RUN npm install
   COPY . .
   CMD ["node", "index.js"]
   ```

4. **Database (MongoDB)**:
   Deployed via Kubernetes.

**Possible Errors**:
- **React build fails**: Ensure Node.js version compatibility.
- **MongoDB connection issues**: Verify service name (`mongodb`).

## Step 4: Create Kubernetes Manifests
1. **MongoDB Deployment and Service**:
   ```yaml
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: mongodb
     namespace: default
   spec:
     replicas: 1
     selector:
       matchLabels:
         app: mongodb
     template:
       metadata:
         labels:
           app: mongodb
       spec:
         containers:
         - name: mongodb
           image: mongo:latest
           ports:
           - containerPort: 27017
   ---
   apiVersion: v1
   kind: Service
   metadata:
     name: mongodb
     namespace: default
   spec:
     selector:
       app: mongodb
     ports:
     - protocol: TCP
       port: 27017
       targetPort: 27017
   ```

2. **Backend Deployment and Service**:
   ```yaml
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: backend
     namespace: default
   spec:
     replicas: 2
     selector:
       matchLabels:
         app: backend
     template:
       metadata:
         labels:
           app: backend
       spec:
         containers:
         - name: backend
           image: my-backend:latest
           ports:
           - containerPort: 3000
   ---
   apiVersion: v1
   kind: Service
   metadata:
     name: backend
     namespace: default
   spec:
     selector:
       app: backend
     ports:
     - protocol: TCP
       port: 3000
       targetPort: 3000
   ```

3. **Frontend Deployment and Service**:
   ```yaml
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: frontend
     namespace: default
   spec:
     replicas: 2
     selector:
       matchLabels:
         app: frontend
     template:
       metadata:
         labels:
           app: frontend
       spec:
         containers:
         - name: frontend
           image: my-frontend:latest
           ports:
           - containerPort: 3000
   ---
   apiVersion: v1
   kind: Service
   metadata:
     name: frontend
     namespace: default
   spec:
     selector:
       app: frontend
     ports:
     - protocol: TCP
       port: 3000
       targetPort: 3000
   ```

4. **Ingress Configuration**:
   ```yaml
   apiVersion: networking.k8s.io/v1
   kind: Ingress
   metadata:
     name: app-ingress
     namespace: default
   spec:
     rules:
     - http:
         paths:
         - path: /
           pathType: Prefix
           backend:
             service:
               name: frontend
               port:
                 number: 3000
   ```

**Possible Errors**:
- **Image pull errors**: Ensure images are loaded locally.
- **Ingress not working**: Verify Ingress controller.

## Step 5: Set Up CI/CD Pipeline with Jenkins
1. **Start Jenkins**:
   ```bash
   systemctl start jenkins
   ```

2. **Configure Jenkins**:
   - Install plugins: Docker, Git, Kubernetes.
   - Add Docker credentials:
     ```bash
     sudo usermod -aG docker jenkins
     systemctl restart jenkins
     ```

3. **Create a Jenkins Pipeline**:
   ```groovy
   pipeline {
       agent any
       stages {
           stage('Build') {
               steps {
                   dir('frontend') {
                       sh 'docker build -t my-frontend:latest .'
                   }
                   dir('backend') {
                       sh 'docker build -t my-backend:latest .'
                   }
               }
           }
           stage('Push') {
               steps {
                   sh 'minikube cache add my-frontend:latest'
                   sh 'minikube cache add my-backend:latest'
               }
           }
           stage('Deploy') {
               steps {
                   sh 'kubectl apply -f k8s/mongodb.yaml'
                   sh 'kubectl apply -f k8s/backend.yaml'
                   sh 'kubectl apply -f k8s/frontend.yaml'
                   sh 'kubectl apply -f k8s/ingress.yaml'
               }
           }
       }
   }
   ```

4. **Configure Jenkins Job**:
   - Create a Pipeline job.
   - Set Git repository path.
   - Specify `Jenkinsfile`.

**Possible Errors**:
- **Jenkins cannot access Docker**: Verify permissions.
- **Pipeline fails on deploy**: Ensure `kubectl` is configured.

## Step 6: Set Up Monitoring with Prometheus and Grafana
1. **Install Prometheus**:
   ```bash
   helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
   helm install prometheus prometheus-community/prometheus
   ```

2. **Install Grafana**:
   ```bash
   helm repo add grafana https://grafana.github.io/helm-charts
   helm install grafana grafana/grafana
   ```

3. **Access Grafana**:
   ```bash
   kubectl get secret --namespace default grafana -o jsonpath="{.data.admin-password}" | base64 --decode
   kubectl port-forward svc/grafana 3000:80
   ```

4. **Configure Grafana**:
   - Add Prometheus data source.
   - Import Kubernetes dashboard (ID 6417).

**Possible Errors**:
- **Helm not installed**: Install Helm.
- **Prometheus not collecting metrics**: Verify endpoints.

## Step 7: Test the Application
1. **Access the Application**:
   ```bash
   minikube ip
   curl http://<minikube-ip>
   ```

2. **Verify Monitoring**:
   Check Grafana dashboards.

**Possible Errors**:
- **Application not accessible**: Verify Ingress rules.
- **Monitoring data missing**: Ensure Prometheus scraping.

## Recommendations
- **Offline Access**: Save Docker images, Helm charts, and manifests.
- **Testing**: Practice with time constraints.
- **Cheatsheets**: Refer to Appendices D and E.


---

### Next Steps
Would you like me to:
1. Proceed with the solution for Task 3?
2. Refine or expand the solution for Task 2 (e.g., add more error handling or alternative CI/CD setup)?
3. Generate the full handbook with all solutions in Markdown or PDF?

Please specify, for example: "Выведи решение для Задачи 3" or "Добавь больше примеров ошибок для Задачи 2".

Спасибо за запрос на добавление дополнительных примеров ошибок для **Задачи 2: Развертывание микросервисов в Kubernetes с CI/CD и мониторингом**. Я расширю решение, добавив больше потенциальных ошибок и способы их устранения, сохраняя структуру и оформление в `<xaiArtifact>` теге. Решение будет на русском языке, с акцентом на ясность и практичность, чтобы оно было полезно для подготовки к олимпиаде IT-Планета 2025. Я обновлю предыдущее решение, добавив новые примеры ошибок в каждом шаге, и выделю их в отдельные подразделы для удобства.

---

## Задача 2: Развертывание микросервисов в Kubernetes с CI/CD и мониторингом

### Описание
Разверните приложение на основе микросервисов в кластере Kubernetes, интегрируйте его с CI/CD пайплайном и настройте мониторинг производительности.

### Цели
- Создать локальный Kubernetes-кластер (например, с помощью Minikube или kind).
- Развернуть приложение из трех микросервисов: frontend (React), backend (Node.js) и база данных (MongoDB) с использованием Kubernetes Deployments и Services.
- Настроить Ingress для доступа к frontend по HTTP.
- Реализовать CI/CD пайплайн (с GitLab CI или Jenkins) для автоматической сборки Docker-образов и деплоя в Kubernetes при коммитах в репозиторий.
- Установить Prometheus и Grafana для мониторинга метрик приложения и кластера.

### Инструменты
Kubernetes, Docker, Git, GitLab CI/Jenkins, Prometheus, Grafana.

### Ожидаемый результат
Полностью функционирующее приложение в Kubernetes с автоматическим деплоем и мониторингом, доступное через Ingress.

---

### Пошаговое решение с расширенными примерами ошибок

#### Шаг 1: Подготовка среды
1. **Установка необходимых инструментов**:
   - **Minikube**:
     ```bash
     curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
     sudo install minikube-linux-amd64 /usr/local/bin/minikube
     ```
   - **kubectl**:
     ```bash
     curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
     sudo install kubectl /usr/local/bin/kubectl
     ```
   - **Docker**:
     ```bash
     sudo apt update
     sudo apt install docker.io -y
     sudo usermod -aG docker $USER
     ```
   - **Git**:
     ```bash
     sudo apt install git -y
     ```
   - **Jenkins**:
     ```bash
     sudo apt install openjdk-11-jdk -y
     wget https://pkg.jenkins.io/debian-stable/binary/jenkins_2.426.3_all.deb
     sudo dpkg -i jenkins_2.426.3_all.deb
     sudo apt install -f
     ```

2. **Проверка установки**:
   ```bash
   minikube version
   kubectl version --client
   docker --version
   git --version
   ```

**Возможные ошибки**:
- **Minikube не запускается из-за отсутствия драйвера**:
  - **Симптом**: Ошибка `Driver "docker" not found`.
  - **Решение**: Убедитесь, что Docker установлен и запущен (`systemctl status docker`). Попробуйте другой драйвер, например, `--driver=virtualbox`.
- **kubectl не может найти конфигурацию**:
  - **Симптом**: Ошибка `The connection to the server localhost:8080 was refused`.
  - **Решение**: Проверьте, существует ли файл `~/.kube/config` (`ls -l ~/.kube/config`). Если нет, выполните `minikube start` для создания конфигурации.
- **Jenkins не запускается**:
  - **Симптом**: Ошибка `Failed to start Jenkins Continuous Integration Server`.
  - **Решение**: Проверьте Java (`java -version`) и логи (`journalctl -u jenkins`). Убедитесь, что порт 8080 свободен (`ss -tuln | grep 8080`).
- **Docker не работает без sudo**:
  - **Симптом**: Ошибка `Got permission denied while trying to connect to the Docker daemon`.
  - **Решение**: Перезайдите в сессию после добавления пользователя в группу `docker` или выполните `newgrp docker`.

---

#### Шаг 2: Создание локального Kubernetes-кластера
1. **Запуск Minikube**:
   ```bash
   minikube start --driver=docker
   ```

2. **Включение Ingress-контроллера**:
   ```bash
   minikube addons enable ingress
   ```

3. **Проверка кластера**:
   ```bash
   kubectl cluster-info
   kubectl get nodes
   ```

**Возможные ошибки**:
- **Minikube не хватает ресурсов**:
  - **Симптом**: Ошибка `Exiting due to RSRC_INSUFFICIENT_MEMORY`.
  - **Решение**: Увеличьте доступную память (`minikube start --memory=4096`) или освободите ресурсы, закрыв другие приложения.
- **Ingress-контроллер не запускается**:
  - **Симптом**: Команда `kubectl get pods -n ingress-nginx` показывает поды в состоянии `CrashLoopBackOff`.
  - **Решение**: Проверьте логи (`kubectl logs <pod-name> -n ingress-nginx`) и убедитесь, что сеть настроена корректно.
- **Кластер не отвечает**:
  - **Симптом**: Ошибка `Unable to connect to the server: dial tcp`.
  - **Решение**: Перезапустите Minikube (`minikube stop && minikube start`) или проверьте сетевые настройки хоста (`ip a`).

---

#### Шаг 3: Настройка приложения с микросервисами
1. **Создание Git-репозитория**:
   ```bash
   mkdir microservices-app
   cd microservices-app
   git init
   ```

2. **Frontend (React)**:
   ```bash
   mkdir frontend
   cd frontend
   npx create-react-app .
   ```
   Создайте `Dockerfile`:
```Dockerfile
FROM node:16
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build
CMD ["npm", "start"]
```

3. **Backend (Node.js)**:
   ```bash
   mkdir ../backend
   cd ../backend
   npm init -y
   npm install express mongodb
   ```
   Создайте `index.js`:
```javascript
const express = require('express');
const { MongoClient } = require('mongodb');
const app = express();
const port = 3000;

app.use(express.json());

const url = 'mongodb://mongodb:27017';
const dbName = 'mydb';

app.get('/data', async (req, res) => {
  let client;
  try {
    client = await MongoClient.connect(url);
    const db = client.db(dbName);
    const data = await db.collection('items').find().toArray();
    res.json(data);
  } catch (err) {
    res.status(500).send(err.message);
  } finally {
    if (client) client.close();
  }
});

app.listen(port, () => console.log(`Backend running on port ${port}`));
```
   Создайте `Dockerfile`:
```Dockerfile
FROM node:16
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
CMD ["node", "index.js"]
```

4. **База данных (MongoDB)**:
   Будет развернута через Kubernetes.

**Возможные ошибки**:
- **Ошибка сборки React**:
  - **Симптом**: Ошибка `npm run build` из-за несовместимости версий.
  - **Решение**: Убедитесь, что используется Node 16 (`node -v`). Очистите кеш npm (`npm cache clean --force`) и переустановите зависимости (`npm install`).
- **Backend не подключается к MongoDB**:
  - **Симптом**: Ошибка `MongoServerSelectionError: connect ECONNREFUSED`.
  - **Решение**: Проверьте, что сервис MongoDB запущен (`kubectl get svc mongodb`) и имя хоста в `index.js` совпадает с именем сервиса (`mongodb`).
- **Docker-образ не собирается**:
  - **Симптом**: Ошибка `COPY failed: file not found`.
  - **Решение**: Убедитесь, что все файлы (например, `package.json`) находятся в правильной директории. Проверьте `.dockerignore`.
- **Недостаточно места для сборки**:
  - **Симптом**: Ошибка `No space left on device`.
  - **Решение**: Очистите неиспользуемые образы и контейнеры (`docker system prune -a`).

---

#### Шаг 4: Создание манифестов Kubernetes
1. **MongoDB Deployment и Service**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mongodb
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mongodb
  template:
    metadata:
      labels:
        app: mongodb
    spec:
      containers:
      - name: mongodb
        image: mongo:latest
        ports:
        - containerPort: 27017
---
apiVersion: v1
kind: Service
metadata:
  name: mongodb
  namespace: default
spec:
  selector:
    app: mongodb
  ports:
  - protocol: TCP
    port: 27017
    targetPort: 27017
```

2. **Backend Deployment и Service**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: default
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: my-backend:latest
        ports:
        - containerPort: 3000
---
apiVersion: v1
kind: Service
metadata:
  name: backend
  namespace: default
spec:
  selector:
    app: backend
  ports:
  - protocol: TCP
    port: 3000
    targetPort: 3000
```

3. **Frontend Deployment и Service**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: default
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: my-frontend:latest
        ports:
        - containerPort: 3000
---
apiVersion: v1
kind: Service
metadata:
  name: frontend
  namespace: default
spec:
  selector:
    app: frontend
  ports:
  - protocol: TCP
    port: 3000
    targetPort: 3000
```

4. **Конфигурация Ingress**:
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: app-ingress
  namespace: default
spec:
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend
            port:
              number: 3000
```

**Возможные ошибки**:
- **Ошибка загрузки образа**:
  - **Симптом**: `ErrImagePull` при `kubectl get pods`.
  - **Решение**: Загрузите образы в Minikube (`minikube cache add my-frontend:latest`) или используйте локальный реестр (`docker tag my-frontend:latest localhost:5000/my-frontend:latest`).
- **Несоответствие селекторов**:
  - **Симптом**: Сервис не находит поды (`kubectl describe svc frontend`).
  - **Решение**: Проверьте, что `matchLabels` в Deployment совпадают с `selector` в Service.
- **Синтаксическая ошибка в манифесте**:
  - **Симптом**: Ошибка `error: error parsing k8s/frontend.yaml`.
  - **Решение**: Проверьте YAML-синтаксис (`kubectl apply -f k8s/frontend.yaml --dry-run=client`).
- **Ingress не маршрутизирует**:
  - **Симптом**: `404 Not Found` при доступе к `minikube ip`.
  - **Решение**: Проверьте статус Ingress (`kubectl describe ingress app-ingress`) и убедитесь, что Ingress-контроллер работает.

---

#### Шаг 5: Настройка CI/CD пайплайна с Jenkins
1. **Запуск Jenkins**:
   ```bash
   systemctl start jenkins
   ```
   Получите начальный пароль:
   ```bash
   cat /var/lib/jenkins/secrets/initialAdminPassword
   ```
   Откройте `http://192.168.1.10:8080` и настройте Jenkins.

2. **Конфигурация Jenkins**:
   - Установите плагины: Docker, Git, Kubernetes.
   - Настройте доступ к Docker:
     ```bash
     sudo usermod -aG docker jenkins
     systemctl restart jenkins
     ```

3. **Создание Jenkinsfile**:
```groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                dir('frontend') {
                    sh 'docker build -t my-frontend:latest .'
                }
                dir('backend') {
                    sh 'docker build -t my-backend:latest .'
                }
            }
        }
        stage('Push') {
            steps {
                sh 'minikube cache add my-frontend:latest'
                sh 'minikube cache add my-backend:latest'
            }
        }
        stage('Deploy') {
            steps {
                sh 'kubectl apply -f k8s/mongodb.yaml'
                sh 'kubectl apply -f k8s/backend.yaml'
                sh 'kubectl apply -f k8s/frontend.yaml'
                sh 'kubectl apply -f k8s/ingress.yaml'
            }
        }
    }
}
```

4. **Настройка задачи Jenkins**:
   - Создайте новую задачу типа Pipeline.
   - Укажите путь к Git-репозиторию (например, `/path/to/microservices-app`).
   - Укажите `Jenkinsfile` как источник скрипта.
   - Запустите сборку вручную или настройте вебхук.

**Возможные ошибки**:
- **Jenkins не может выполнить Docker-команды**:
  - **Симптом**: Ошибка `docker: permission denied`.
  - **Решение**: Проверьте права доступа к сокету Docker (`ls -l /var/run/docker.sock`) и убедитесь, что пользователь `jenkins` в группе `docker`.
- **Ошибка доступа к Git**:
  - **Симптом**: `Failed to connect to repository`.
  - **Решение**: Настройте SSH-ключи для пользователя `jenkins` (`sudo -u jenkins ssh-keygen`) и добавьте их в Git-сервер.
- **kubectl не работает в Jenkins**:
  - **Симптом**: Ошибка `kubectl: command not found`.
  - **Решение**: Установите kubectl на сервере Jenkins (`sudo snap install kubectl --classic`) и скопируйте `~/.kube/config` в домашнюю директорию `jenkins` (`/var/lib/jenkins/.kube/`).
- **Пайплайн зависает на этапе Deploy**:
  - **Симптом**: Задача не завершается, логи показывают ожидание.
  - **Решение**: Проверьте, что манифесты находятся в правильной директории (`k8s/`) и доступны Jenkins.

---

#### Шаг 6: Настройка мониторинга с Prometheus и Grafana
1. **Установка Prometheus**:
   ```bash
   helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
   helm install prometheus prometheus-community/prometheus
   ```

2. **Установка Grafana**:
   ```bash
   helm repo add grafana https://grafana.github.io/helm-charts
   helm install grafana grafana/grafana
   ```

3. **Доступ к Grafana**:
   Получите пароль администратора:
   ```bash
   kubectl get secret --namespace default grafana -o jsonpath="{.data.admin-password}" | base64 --decode
   ```
   Перенаправьте порт:
   ```bash
   kubectl port-forward svc/grafana 3000:80
   ```
   Откройте `http://localhost:3000` (логин: `admin`).

4. **Конфигурация Grafana**:
   - Добавьте Prometheus как источник данных (`http://prometheus-server`).
   - Импортируйте дашборд для Kubernetes (например, ID 6417).

**Возможные ошибки**:
- **Helm не установлен**:
  - **Симптом**: Ошибка `helm: command not found`.
  - **Решение**: Установите Helm (`curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash`).
- **Prometheus не собирает метрики**:
  - **Симптом**: Grafana показывает `No data`.
  - **Решение**: Проверьте, что Prometheus настроен на сбор метрик (`kubectl get svc prometheus-server`) и поды экспортируют метрики.
- **Grafana недоступна**:
  - **Симптом**: Ошибка `connection refused` при доступе к `localhost:3000`.
  - **Решение**: Убедитесь, что порт перенаправлен корректно (`kubectl port-forward`) и сервис Grafana работает (`kubectl get svc grafana`).
- **Ошибка авторизации в Grafana**:
  - **Симптом**: Неверный пароль.
  - **Решение**: Повторно извлеките пароль (`kubectl get secret`) или сбросьте его через `kubectl edit secret grafana`.

---

#### Шаг 7: Тестирование приложения
1. **Доступ к приложению**:
   Получите IP Minikube:
   ```bash
   minikube ip
   ```
   Проверьте доступ: `curl http://<minikube-ip>`.

2. **Проверка мониторинга**:
   Откройте Grafana и убедитесь, что метрики кластера и приложения отображаются.

**Возможные ошибки**:
- **Приложение недоступно**:
  - **Симптом**: `404 Not Found` или `503 Service Unavailable`.
  - **Решение**: Проверьте статус Ingress (`kubectl describe ingress app-ingress`), подов (`kubectl get pods`) и логов (`kubectl logs <pod-name>`).
- **Frontend не загружается**:
  - **Симптом**: Пустая страница или ошибка в консоли браузера.
  - **Решение**: Проверьте, что React-сборка завершилась успешно, и образ корректен (`docker run -it my-frontend:latest`).
- **Мониторинг не показывает данные**:
  - **Симптом**: Дашборды пустые.
  - **Решение**: Проверьте конфигурацию Prometheus (`kubectl describe configmap prometheus-server`) и убедитесь, что метрики экспортируются.

---

### Рекомендации
- **Офлайн-доступ**: Сохраните Docker-образы (`docker save -o image.tar my-frontend:latest`), Helm-чарты и манифесты на USB-накопитель:
  ```bash
  tar -czf k8s_manifests.tar.gz k8s/
  ```
- **Тестирование**: Практикуйтесь в развертывании кластера и пайплайна с ограничением по времени (например, 30 минут).
- **Шпаргалки**: Используйте Приложения D (Jenkins) и E (Kubernetes) для быстрого доступа к командам:
  ```bash
  grep kubectl cheatsheet_k8s.txt
  ```


# Решение для Задачи 2: Развертывание микросервисов в Kubernetes с CI/CD и мониторингом

## Шаг 1: Подготовка среды
1. **Установка необходимых инструментов**:
   - **Minikube**:
     ```bash
     curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
     sudo install minikube-linux-amd64 /usr/local/bin/minikube
     ```
   - **kubectl**:
     ```bash
     curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
     sudo install kubectl /usr/local/bin/kubectl
     ```
   - **Docker**:
     ```bash
     sudo apt update
     sudo apt install docker.io -y
     sudo usermod -aG docker $USER
     ```
   - **Git**:
     ```bash
     sudo apt install git -y
     ```
   - **Jenkins**:
     ```bash
     sudo apt install openjdk-11-jdk -y
     wget https://pkg.jenkins.io/debian-stable/binary/jenkins_2.426.3_all.deb
     sudo dpkg -i jenkins_2.426.3_all.deb
     sudo apt install -f
     ```

2. **Проверка установки**:
   ```bash
   minikube version
   kubectl version --client
   docker --version
   git --version
   ```

**Возможные ошибки**:
- **Minikube не запускается из-за отсутствия драйвера**:
  - **Симптом**: Ошибка `Driver "docker" not found`.
  - **Решение**: Убедитесь, что Docker установлен и запущен (`systemctl status docker`). Попробуйте `--driver=virtualbox`.
- **kubectl не может найти конфигурацию**:
  - **Симптом**: Ошибка `The connection to the server localhost:8080 was refused`.
  - **Решение**: Проверьте `~/.kube/config` (`ls -l ~/.kube/config`). Выполните `minikube start`.
- **Jenkins не запускается**:
  - **Симптом**: Ошибка `Failed to start Jenkins Continuous Integration Server`.
  - **Решение**: Проверьте Java (`java -version`) и логи (`journalctl -u jenkins`). Убедитесь, что порт 8080 свободен (`ss -tuln | grep 8080`).
- **Docker не работает без sudo**:
  - **Симптом**: Ошибка `Got permission denied while trying to connect to the Docker daemon`.
  - **Решение**: Перезайдите в сессию или выполните `newgrp docker`.

## Шаг 2: Создание локального Kubernetes-кластера
1. **Запуск Minikube**:
   ```bash
   minikube start --driver=docker
   ```

2. **Включение Ingress-контроллера**:
   ```bash
   minikube addons enable ingress
   ```

3. **Проверка кластера**:
   ```bash
   kubectl cluster-info
   kubectl get nodes
   ```

**Возможные ошибки**:
- **Minikube не хватает ресурсов**:
  - **Симптом**: Ошибка `Exiting due to RSRC_INSUFFICIENT_MEMORY`.
  - **Решение**: Увеличьте память (`minikube start --memory=4096`) или закройте другие приложения.
- **Ingress-контроллер не запускается**:
  - **Симптом**: `kubectl get pods -n ingress-nginx` показывает `CrashLoopBackOff`.
  - **Решение**: Проверьте логи (`kubectl logs <pod-name> -n ingress-nginx`) и сетевые настройки.
- **Кластер не отвечает**:
  - **Симптом**: Ошибка `Unable to connect to the server: dial tcp`.
  - **Решение**: Перезапустите Minikube (`minikube stop && minikube start`) или проверьте сеть (`ip a`).

## Шаг 3: Настройка приложения с микросервисами
1. **Создание Git-репозитория**:
   ```bash
   mkdir microservices-app
   cd microservices-app
   git init
   ```

2. **Frontend (React)**:
   ```bash
   mkdir frontend
   cd frontend
   npx create-react-app .
   ```
   Создайте `Dockerfile`:
   ```Dockerfile
   FROM node:16
   WORKDIR /app
   COPY package*.json ./
   RUN npm install
   COPY . .
   RUN npm run build
   CMD ["npm", "start"]
   ```

3. **Backend (Node.js)**:
   ```bash
   mkdir ../backend
   cd ../backend
   npm init -y
   npm install express mongodb
   ```
   Создайте `index.js`:
   ```javascript
   const express = require('express');
   const { MongoClient } = require('mongodb');
   const app = express();
   const port = 3000;

   app.use(express.json());

   const url = 'mongodb://mongodb:27017';
   const dbName = 'mydb';

   app.get('/data', async (req, res) => {
     let client;
     try {
       client = await MongoClient.connect(url);
       const db = client.db(dbName);
       const data = await db.collection('items').find().toArray();
       res.json(data);
     } catch (err) {
       res.status(500).send(err.message);
     } finally {
       if (client) client.close();
     }
   });

   app.listen(port, () => console.log(`Backend running on port ${port}`));
   ```
   Создайте `Dockerfile`:
   ```Dockerfile
   FROM node:16
   WORKDIR /app
   COPY package*.json ./
   RUN npm install
   COPY . .
   CMD ["node", "index.js"]
   ```

4. **База данных (MongoDB)**:
   Развертывается через Kubernetes.

**Возможные ошибки**:
- **Ошибка сборки React**:
  - **Симптом**: Ошибка `npm run build` из-за несовместимости версий.
  - **Решение**: Используйте Node 16 (`node -v`). Очистите кеш (`npm cache clean --force`) и переустановите зависимости (`npm install`).
- **Backend не подключается к MongoDB**:
  - **Симптом**: Ошибка `MongoServerSelectionError: connect ECONNREFUSED`.
  - **Решение**: Проверьте сервис MongoDB (`kubectl get svc mongodb`) и имя хоста в `index.js`.
- **Docker-образ не собирается**:
  - **Симптом**: Ошибка `COPY failed: file not found`.
  - **Решение**: Проверьте наличие файлов (`ls -l`) и `.dockerignore`.
- **Недостаточно места для сборки**:
  - **Симптом**: Ошибка `No space left on device`.
  - **Решение**: Очистите образы и контейнеры (`docker system prune -a`).

## Шаг 4: Создание манифестов Kubernetes
1. **MongoDB Deployment и Service**:
   ```yaml
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: mongodb
     namespace: default
   spec:
     replicas: 1
     selector:
       matchLabels:
         app: mongodb
     template:
       metadata:
         labels:
           app: mongodb
       spec:
         containers:
         - name: mongodb
           image: mongo:latest
           ports:
           - containerPort: 27017
   ---
   apiVersion: v1
   kind: Service
   metadata:
     name: mongodb
     namespace: default
   spec:
     selector:
       app: mongodb
     ports:
     - protocol: TCP
       port: 27017
       targetPort: 27017
   ```

2. **Backend Deployment и Service**:
   ```yaml
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: backend
     namespace: default
   spec:
     replicas: 2
     selector:
       matchLabels:
         app: backend
     template:
       metadata:
         labels:
           app: backend
       spec:
         containers:
         - name: backend
           image: my-backend:latest
           ports:
           - containerPort: 3000
   ---
   apiVersion: v1
   kind: Service
   metadata:
     name: backend
     namespace: default
   spec:
     selector:
       app: backend
     ports:
     - protocol: TCP
       port: 3000
       targetPort: 3000
   ```

3. **Frontend Deployment и Service**:
   ```yaml
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: frontend
     namespace: default
   spec:
     replicas: 2
     selector:
       matchLabels:
         app: frontend
     template:
       metadata:
         labels:
           app: frontend
       spec:
         containers:
         - name: frontend
           image: my-frontend:latest
           ports:
           - containerPort: 3000
   ---
   apiVersion: v1
   kind: Service
   metadata:
     name: frontend
     namespace: default
   spec:
     selector:
       app: frontend
     ports:
     - protocol: TCP
       port: 3000
       targetPort: 3000
   ```

4. **Конфигурация Ingress**:
   ```yaml
   apiVersion: networking.k8s.io/v1
   kind: Ingress
   metadata:
     name: app-ingress
     namespace: default
   spec:
     rules:
     - http:
         paths:
         - path: /
           pathType: Prefix
           backend:
             service:
               name: frontend
               port:
                 number: 3000
   ```

**Возможные ошибки**:
- **Ошибка загрузки образа**:
  - **Симптом**: `ErrImagePull` при `kubectl get pods`.
  - **Решение**: Загрузите образы в Minikube (`minikube cache add my-frontend:latest`).
- **Несоответствие селекторов**:
  - **Симптом**: Сервис не находит поды (`kubectl describe svc frontend`).
  - **Решение**: Проверьте `matchLabels` и `selector`.
- **Синтаксическая ошибка в манифесте**:
  - **Симптом**: Ошибка `error: error parsing k8s/frontend.yaml`.
  - **Решение**: Проверьте синтаксис (`kubectl apply -f k8s/frontend.yaml --dry-run=client`).
- **Ingress не маршрутизирует**:
  - **Симптом**: `404 Not Found` при доступе к `minikube ip`.
  - **Решение**: Проверьте Ingress (`kubectl describe ingress app-ingress`).

## Шаг 5: Настройка CI/CD пайплайна с Jenkins
1. **Запуск Jenkins**:
   ```bash
   systemctl start jenkins
   ```

2. **Конфигурация Jenkins**:
   - Установите плагины: Docker, Git, Kubernetes.
   - Настройте доступ к Docker:
     ```bash
     sudo usermod -aG docker jenkins
     systemctl restart jenkins
     ```

3. **Создание Jenkinsfile**:
   ```groovy
   pipeline {
       agent any
       stages {
           stage('Build') {
               steps {
                   dir('frontend') {
                       sh 'docker build -t my-frontend:latest .'
                   }
                   dir('backend') {
                       sh 'docker build -t my-backend:latest .'
                   }
               }
           }
           stage('Push') {
               steps {
                   sh 'minikube cache add my-frontend:latest'
                   sh 'minikube cache add my-backend:latest'
               }
           }
           stage('Deploy') {
               steps {
                   sh 'kubectl apply -f k8s/mongodb.yaml'
                   sh 'kubectl apply -f k8s/backend.yaml'
                   sh 'kubectl apply -f k8s/frontend.yaml'
                   sh 'kubectl apply -f k8s/ingress.yaml'
               }
           }
       }
   }
   ```

4. **Настройка задачи Jenkins**:
   - Создайте Pipeline задачу.
   - Укажите путь к репозиторию.
   - Укажите `Jenkinsfile`.

**Возможные ошибки**:
- **Jenkins не может выполнить Docker-команды**:
  - **Симптом**: Ошибка `docker: permission denied`.
  - **Решение**: Проверьте права доступа к `/var/run/docker.sock`.
- **Ошибка доступа к Git**:
  - **Симптом**: `Failed to connect to repository`.
  - **Решение**: Настройте SSH-ключи (`sudo -u jenkins ssh-keygen`).
- **kubectl не работает в Jenkins**:
  - **Симптом**: Ошибка `kubectl: command not found`.
  - **Решение**: Установите kubectl (`sudo snap install kubectl --classic`) и настройте `~/.kube/config`.
- **Пайплайн зависает на этапе Deploy**:
  - **Симптом**: Задача не завершается.
  - **Решение**: Проверьте наличие манифестов в `k8s/`.

## Шаг 6: Настройка мониторинга с Prometheus и Grafana
1. **Установка Prometheus**:
   ```bash
   helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
   helm install prometheus prometheus-community/prometheus
   ```

2. **Установка Grafana**:
   ```bash
   helm repo add grafana https://grafana.github.io/helm-charts
   helm install grafana grafana/grafana
   ```

3. **Доступ к Grafana**:
   ```bash
   kubectl get secret --namespace default grafana -o jsonpath="{.data.admin-password}" | base64 --decode
   kubectl port-forward svc/grafana 3000:80
   ```

4. **Конфигурация Grafana**:
   - Добавьте Prometheus (`http://prometheus-server`).
   - Импортируйте дашборд (ID 6417).

**Возможные ошибки**:
- **Helm не установлен**:
  - **Симптом**: Ошибка `helm: command not found`.
  - **Решение**: Установите Helm (`curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash`).
- **Prometheus не собирает метрики**:
  - **Симптом**: Grafana показывает `No data`.
  - **Решение**: Проверьте конфигурацию (`kubectl get svc prometheus-server`).
- **Grafana недоступна**:
  - **Симптом**: Ошибка `connection refused`.
  - **Решение**: Проверьте порт (`kubectl port-forward`).
- **Ошибка авторизации в Grafana**:
  - **Симптом**: Неверный пароль.
  - **Решение**: Извлеките пароль повторно (`kubectl get secret`).

## Шаг 7: Тестирование приложения
1. **Доступ к приложению**:
   ```bash
   minikube ip
   curl http://<minikube-ip>
   ```

2. **Проверка мониторинга**:
   Проверьте метрики в Grafana.

**Возможные ошибки**:
- **Приложение недоступно**:
  - **Симптом**: `404 Not Found` или `503 Service Unavailable`.
  - **Решение**: Проверьте Ingress (`kubectl describe ingress`), поды (`kubectl get pods`), логи (`kubectl logs <pod-name>`).
- **Frontend не загружается**:
  - **Симптом**: Пустая страница.
  - **Решение**: Проверьте сборку React и образ (`docker run -it my-frontend:latest`).
- **Мониторинг не показывает данные**:
  - **Симптом**: Дашборды пустые.
  - **Решение**: Проверьте конфигурацию Prometheus (`kubectl describe configmap prometheus-server`).

## Рекомендации
- **Офлайн-доступ**: Сохраните образы, чарты и манифесты:
  ```bash
  tar -czf k8s_manifests.tar.gz k8s/
  ```
- **Тестирование**: Практикуйтесь с ограничением времени.
- **Шпаргалки**: Используйте Приложения D и E:
  ```bash
  grep kubectl cheatsheet_k8s.txt
  ```


---

### Следующие шаги
Я добавил больше примеров ошибок для Задачи 2, сохранив структуру и добавив новые сценарии. Хотите:
1. Выведите решение для Задачи 3 с аналогичным уровнем детализации?
2. Добавить еще больше ошибок или конкретные случаи для Задачи 2 (например, ошибки в сетевой конфигурации)?
3. Сгенерировать полный справочник с решениями в Markdown или PDF?

Пожалуйста, уточните, например: "Выведи решение для Задачи 3" или "Добавь ошибки для сетевых настроек в Задаче 2".


Спасибо за запрос на добавление дополнительных примеров ошибок, связанных с сетевыми настройками, для **Задачи 2: Развертывание микросервисов в Kubernetes с CI/CD и мониторингом**. Я обновлю предыдущее решение, добавив специфические сетевые ошибки и способы их устранения, сохраняя структуру и оформление в `<xaiArtifact>` теге. Решение будет на русском языке, с акцентом на ясность и практичность, чтобы помочь в подготовке к олимпиаде IT-Планета 2025. Я сосредоточусь на сетевых аспектах, таких как конфигурация Ingress, DNS, сервисы Kubernetes, сетевые политики и взаимодействие с Minikube, добавив новые примеры ошибок в соответствующих шагах.

---

## Задача 2: Развертывание микросервисов в Kubernetes с CI/CD и мониторингом

### Описание
Разверните приложение на основе микросервисов в кластере Kubernetes, интегрируйте его с CI/CD пайплайном и настройте мониторинг производительности.

### Цели
- Создать локальный Kubernetes-кластер (например, с помощью Minikube или kind).
- Развернуть приложение из трех микросервисов: frontend (React), backend (Node.js) и база данных (MongoDB) с использованием Kubernetes Deployments и Services.
- Настроить Ingress для доступа к frontend по HTTP.
- Реализовать CI/CD пайплайн (с GitLab CI или Jenkins) для автоматической сборки Docker-образов и деплоя в Kubernetes при коммитах в репозиторий.
- Установить Prometheus и Grafana для мониторинга метрик приложения и кластера.

### Инструменты
Kubernetes, Docker, Git, GitLab CI/Jenkins, Prometheus, Grafana.

### Ожидаемый результат
Полностью функционирующее приложение в Kubernetes с автоматическим деплоем и мониторингом, доступное через Ingress.

---

### Пошаговое решение с расширенными сетевыми ошибками

#### Шаг 1: Подготовка среды
1. **Установка необходимых инструментов**:
   - **Minikube**:
     ```bash
     curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
     sudo install minikube-linux-amd64 /usr/local/bin/minikube
     ```
   - **kubectl**:
     ```bash
     curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
     sudo install kubectl /usr/local/bin/kubectl
     ```
   - **Docker**:
     ```bash
     sudo apt update
     sudo apt install docker.io -y
     sudo usermod -aG docker $USER
     ```
   - **Git**:
     ```bash
     sudo apt install git -y
     ```
   - **Jenkins**:
     ```bash
     sudo apt install openjdk-11-jdk -y
     wget https://pkg.jenkins.io/debian-stable/binary/jenkins_2.426.3_all.deb
     sudo dpkg -i jenkins_2.426.3_all.deb
     sudo apt install -f
     ```

2. **Проверка установки**:
   ```bash
   minikube version
   kubectl version --client
   docker --version
   git --version
   ```

**Возможные ошибки**:
- **Minikube не запускается из-за сетевых конфликтов**:
  - **Симптом**: Ошибка `Failed to start network: conflicting subnet`.
  - **Решение**: Проверьте сетевые настройки Minikube (`minikube config get network`). Измените подсеть, если она конфликтует с хостовой сетью:
    ```bash
    minikube start --driver=docker --network-plugin=cni --cni=flannel
    ```
- **Docker не может связаться с сетью**:
  - **Симптом**: Ошибка `Cannot connect to the Docker daemon at unix:///var/run/docker.sock`.
  - **Решение**: Убедитесь, что Docker-сервис запущен (`systemctl start docker`) и проверьте сетевые настройки хоста (`ip a`).

---

#### Шаг 2: Создание локального Kubernetes-кластера
1. **Запуск Minikube**:
   ```bash
   minikube start --driver=docker
   ```

2. **Включение Ingress-контроллера**:
   ```bash
   minikube addons enable ingress
   ```

3. **Проверка кластера**:
   ```bash
   kubectl cluster-info
   kubectl get nodes
   ```

**Возможные сетевые ошибки**:
- **Minikube не может разрешить DNS**:
  - **Симптом**: Ошибка `Temporary Error: DNS resolution failed` при запуске Minikube.
  - **Решение**: Проверьте DNS-серверы хоста (`cat /etc/resolv.conf`). Укажите публичные DNS, например:
    ```bash
    sudo sh -c 'echo "nameserver 8.8.8.8" >> /etc/resolv.conf'
    minikube start --driver=docker --dns 8.8.8.8
    ```
- **Ingress-контроллер не получает внешний IP**:
  - **Симптом**: `kubectl get ingress` показывает `<pending>` в столбце ADDRESS.
  - **Решение**: Убедитесь, что Ingress-контроллер запущен (`kubectl get pods -n ingress-nginx`). Проверьте логи:
    ```bash
    kubectl logs -n ingress-nginx <ingress-pod-name>
    ```
    Если проблема сохраняется, перезапустите addon:
    ```bash
    minikube addons disable ingress
    minikube addons enable ingress
    ```
- **Сетевой плагин CNI не работает**:
  - **Симптом**: Поды в состоянии `Pending` с ошибкой `Failed to create pod sandbox: network plugin is not ready`.
  - **Решение**: Проверьте статус CNI-плагина (`kubectl get pods -n kube-system | grep cni`). Переустановите плагин:
    ```bash
    minikube start --network-plugin=cni --cni=flannel
    ```

---

#### Шаг 3: Настройка приложения с микросервисами
1. **Создание Git-репозитория**:
   ```bash
   mkdir microservices-app
   cd microservices-app
   git init
   ```

2. **Frontend (React)**:
   ```bash
   mkdir frontend
   cd frontend
   npx create-react-app .
   ```
   Создайте `Dockerfile`:
```Dockerfile
FROM node:16
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build
CMD ["npm", "start"]
```

3. **Backend (Node.js)**:
   ```bash
   mkdir ../backend
   cd ../backend
   npm init -y
   npm install express mongodb
   ```
   Создайте `index.js`:
```javascript
const express = require('express');
const { MongoClient } = require('mongodb');
const app = express();
const port = 3000;

app.use(express.json());

const url = 'mongodb://mongodb:27017';
const dbName = 'mydb';

app.get('/data', async (req, res) => {
  let client;
  try {
    client = await MongoClient.connect(url);
    const db = client.db(dbName);
    const data = await db.collection('items').find().toArray();
    res.json(data);
  } catch (err) {
    res.status(500).send(err.message);
  } finally {
    if (client) client.close();
  }
});

app.listen(port, () => console.log(`Backend running on port ${port}`));
```
   Создайте `Dockerfile`:
```Dockerfile
FROM node:16
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
CMD ["node", "index.js"]
```

4. **База данных (MongoDB)**:
   Развертывается через Kubernetes.

**Возможные сетевые ошибки**:
- **Backend не может разрешить имя сервиса MongoDB**:
  - **Симптом**: Ошибка `MongoServerSelectionError: getaddrinfo ENOTFOUND mongodb`.
  - **Решение**: Проверьте, что сервис `mongodb` существует (`kubectl get svc mongodb`). Убедитесь, что CoreDNS работает:
    ```bash
    kubectl get pods -n kube-system | grep coredns
    ```
    Если CoreDNS не работает, перезапустите его:
    ```bash
    kubectl delete pod -n kube-system -l k8s-app=kube-dns
    ```
- **Frontend не может связаться с backend**:
  - **Симптом**: Ошибка CORS или `Connection refused` в консоли браузера.
  - **Решение**: Проверьте, что сервис `backend` доступен (`kubectl get svc backend`). Добавьте CORS в `index.js`:
    ```javascript
    app.use((req, res, next) => {
      res.header('Access-Control-Allow-Origin', '*');
      next();
    });
    ```

---

#### Шаг 4: Создание манифестов Kubernetes
1. **MongoDB Deployment и Service**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mongodb
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mongodb
  template:
    metadata:
      labels:
        app: mongodb
    spec:
      containers:
      - name: mongodb
        image: mongo:latest
        ports:
        - containerPort: 27017
---
apiVersion: v1
kind: Service
metadata:
  name: mongodb
  namespace: default
spec:
  selector:
    app: mongodb
  ports:
  - protocol: TCP
    port: 27017
    targetPort: 27017
```

2. **Backend Deployment и Service**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: default
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: my-backend:latest
        ports:
        - containerPort: 3000
---
apiVersion: v1
kind: Service
metadata:
  name: backend
  namespace: default
spec:
  selector:
    app: backend
  ports:
  - protocol: TCP
    port: 3000
    targetPort: 3000
```

3. **Frontend Deployment и Service**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: default
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: my-frontend:latest
        ports:
        - containerPort: 3000
---
apiVersion: v1
kind: Service
metadata:
  name: frontend
  namespace: default
spec:
  selector:
    app: frontend
  ports:
  - protocol: TCP
    port: 3000
    targetPort: 3000
```

4. **Конфигурация Ingress**:
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: app-ingress
  namespace: default
spec:
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend
            port:
              number: 3000
```

**Возможные сетевые ошибки**:
- **Ingress не маршрутизирует трафик**:
  - **Симптом**: Ошибка `502 Bad Gateway` при доступе к `minikube ip`.
  - **Решение**: Проверьте, что сервис `frontend` работает (`kubectl get svc frontend`) и поды активны (`kubectl get pods -l app=frontend`). Убедитесь, что Ingress-контроллер настроен правильно:
    ```bash
    kubectl get ingress app-ingress -o yaml
    ```
- **Службы не общаются из-за сетевых политик**:
  - **Симптом**: Backend не может подключиться к MongoDB, хотя сервис существует.
  - **Решение**: Проверьте наличие сетевых политик (`kubectl get networkpolicy`). Если они блокируют трафик, создайте политику для разрешения:
    ```yaml
    apiVersion: networking.k8s.io/v1
    kind: NetworkPolicy
    metadata:
      name: allow-backend-to-mongodb
      namespace: default
    spec:
      podSelector:
        matchLabels:
          app: mongodb
      policyTypes:
      - Ingress
      ingress:
      - from:
        - podSelector:
            matchLabels:
              app: backend
        ports:
        - protocol: TCP
          port: 27017
    ```
    Примените: `kubectl apply -f network-policy.yaml`.
- **Проблемы с балансировкой нагрузки**:
  - **Симптом**: Запросы к сервису `frontend` иногда возвращают ошибки.
  - **Решение**: Проверьте тип сервиса (`kubectl get svc frontend -o yaml`). Убедитесь, что используется `ClusterIP` и балансировка работает:
    ```bash
    kubectl describe svc frontend
    ```
    Если поды не отвечают, проверьте их состояние (`kubectl describe pod -l app=frontend`).

---

#### Шаг 5: Настройка CI/CD пайплайна с Jenkins
1. **Запуск Jenkins**:
   ```bash
   systemctl start jenkins
   ```
   Получите начальный пароль:
   ```bash
   cat /var/lib/jenkins/secrets/initialAdminPassword
   ```
   Откройте `http://192.168.1.10:8080` и настройте Jenkins.

2. **Конфигурация Jenkins**:
   - Установите плагины: Docker, Git, Kubernetes.
   - Настройте доступ к Docker:
     ```bash
     sudo usermod -aG docker jenkins
     systemctl restart jenkins
     ```

3. **Создание Jenkinsfile**:
```groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                dir('frontend') {
                    sh 'docker build -t my-frontend:latest .'
                }
                dir('backend') {
                    sh 'docker build -t my-backend:latest .'
                }
            }
        }
        stage('Push') {
            steps {
                sh 'minikube cache add my-frontend:latest'
                sh 'minikube cache add my-backend:latest'
            }
        }
        stage('Deploy') {
            steps {
                sh 'kubectl apply -f k8s/mongodb.yaml'
                sh 'kubectl apply -f k8s/backend.yaml'
                sh 'kubectl apply -f k8s/frontend.yaml'
                sh 'kubectl apply -f k8s/ingress.yaml'
            }
        }
    }
}
```

4. **Настройка задачи Jenkins**:
   - Создайте новую задачу типа Pipeline.
   - Укажите путь к Git-репозиторию (например, `/path/to/microservices-app`).
   - Укажите `Jenkinsfile` как источник скрипта.
   - Запустите сборку вручную или настройте вебхук.

**Возможные сетевые ошибки**:
- **Jenkins не может подключиться к Kubernetes API**:
  - **Симптом**: Ошибка `Failed to connect to Kubernetes API` в логах Jenkins.
  - **Решение**: Скопируйте `~/.kube/config` в `/var/lib/jenkins/.kube/`:
    ```bash
    sudo mkdir -p /var/lib/jenkins/.kube
    sudo cp ~/.kube/config /var/lib/jenkins/.kube/
    sudo chown jenkins:jenkins /var/lib/jenkins/.kube/config
    ```
    Проверьте доступ:
    ```bash
    sudo -u jenkins kubectl get nodes
    ```
- **Сетевые задержки в пайплайне**:
  - **Симптом**: Этап `Deploy` выполняется медленно или зависает.
  - **Решение**: Проверьте сетевую нагрузку на хосте (`iftop` или `nload`). Убедитесь, что Minikube имеет достаточно ресурсов:
    ```bash
    minikube stop
    minikube start --memory=4096 --cpus=2
    ```

---

#### Шаг 6: Настройка мониторинга с Prometheus и Grafana
1. **Установка Prometheus**:
   ```bash
   helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
   helm install prometheus prometheus-community/prometheus
   ```

2. **Установка Grafana**:
   ```bash
   helm repo add grafana https://grafana.github.io/helm-charts
   helm install grafana grafana/grafana
   ```

3. **Доступ к Grafana**:
   Получите пароль администратора:
   ```bash
   kubectl get secret --namespace default grafana -o jsonpath="{.data.admin-password}" | base64 --decode
   ```
   Перенаправьте порт:
   ```bash
   kubectl port-forward svc/grafana 3000:80
   ```
   Откройте `http://localhost:3000` (логин: `admin`).

4. **Конфигурация Grafana**:
   - Добавьте Prometheus как источник данных (`http://prometheus-server`).
   - Импортируйте дашборд для Kubernetes (например, ID 6417).

**Возможные сетевые ошибки**:
- **Prometheus не может обнаружить сервисы**:
  - **Симптом**: Метрики не собираются, в Prometheus пустые таргеты.
  - **Решение**: Проверьте конфигурацию service discovery:
    ```bash
    kubectl describe configmap prometheus-server
    ```
    Убедитесь, что сервисы имеют аннотации для Prometheus:
    ```yaml
    metadata:
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "3000"
    ```
    Примените изменения к сервису `backend`:
    ```bash
    kubectl edit svc backend
    ```
- **Grafana не может подключиться к Prometheus**:
  - **Симптом**: Ошибка `Connection refused` при добавлении источника данных.
  - **Решение**: Проверьте, что сервис `prometheus-server` доступен:
    ```bash
    kubectl get svc prometheus-server
    ```
    Попробуйте перенаправить порт для проверки:
    ```bash
    kubectl port-forward svc/prometheus-server 9090:80
    ```
    Доступ: `http://localhost:9090`.

---

#### Шаг 7: Тестирование приложения
1. **Доступ к приложению**:
   Получите IP Minikube:
   ```bash
   minikube ip
   ```
   Проверьте доступ: `curl http://<minikube-ip>`.

2. **Проверка мониторинга**:
   Откройте Grafana и убедитесь, что метрики кластера и приложения отображаются.

**Возможные сетевые ошибки**:
- **Minikube IP недоступен извне**:
  - **Симптом**: `curl http://<minikube-ip>` возвращает `Connection timed out`.
  - **Решение**: Проверьте, что Minikube использует правильный сетевой интерфейс:
    ```bash
    minikube ip
    ip a
    ```
    Если IP недоступен, используйте туннель:
    ```bash
    minikube tunnel
    ```
- **Трафик блокируется хостовым фаерволом**:
  - **Симптом**: Ошибка `Connection refused` при доступе к приложению.
  - **Решение**: Проверьте правила iptables на хосте:
    ```bash
    sudo iptables -L
    ```
    Разрешите трафик на нужные порты:
    ```bash
    sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT
    ```

---

### Рекомендации
- **Офлайн-доступ**: Сохраните Docker-образы, Helm-чарты и манифесты на USB-накопитель:
  ```bash
  docker save -o my-frontend.tar my-frontend:latest
  tar -czf k8s_manifests.tar.gz k8s/
  ```
- **Тестирование**: Практикуйтесь в развертывании с ограничением по времени (30 минут).
- **Шпаргалки**: Используйте Приложения D (Jenkins) и E (Kubernetes) для команд:
  ```bash
  grep kubectl cheatsheet_k8s.txt
  ```
- **Сетевые тесты**: Используйте `ping`, `nslookup` и `curl` для диагностики сетевых проблем:
  ```bash
  nslookup mongodb.default.svc.cluster.local
  ```


# Решение для Задачи 2: Развертывание микросервисов в Kubernetes с CI/CD и мониторингом

## Шаг 1: Подготовка среды
1. **Установка необходимых инструментов**:
   - **Minikube**:
     ```bash
     curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
     sudo install minikube-linux-amd64 /usr/local/bin/minikube
     ```
   - **kubectl**:
     ```bash
     curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
     sudo install kubectl /usr/local/bin/kubectl
     ```
   - **Docker**:
     ```bash
     sudo apt update
     sudo apt install docker.io -y
     sudo usermod -aG docker $USER
     ```
   - **Git**:
     ```bash
     sudo apt install git -y
     ```
   - **Jenkins**:
     ```bash
     sudo apt install openjdk-11-jdk -y
     wget https://pkg.jenkins.io/debian-stable/binary/jenkins_2.426.3_all.deb
     sudo dpkg -i jenkins_2.426.3_all.deb
     sudo apt install -f
     ```

2. **Проверка установки**:
   ```bash
   minikube version
   kubectl version --client
   docker --version
   git --version
   ```

**Возможные сетевые ошибки**:
- **Minikube не запускается из-за сетевых конфликтов**:
  - **Симптом**: Ошибка `Failed to start network: conflicting subnet`.
  - **Решение**: Проверьте настройки сети (`minikube config get network`). Измените подсеть:
    ```bash
    minikube start --driver=docker --network-plugin=cni --cni=flannel
    ```
- **Docker не может связаться с сетью**:
  - **Симптом**: Ошибка `Cannot connect to the Docker daemon`.
  - **Решение**: Убедитесь, что Docker запущен (`systemctl start docker`) и проверьте сеть (`ip a`).

## Шаг 2: Создание локального Kubernetes-кластера
1. **Запуск Minikube**:
   ```bash
   minikube start --driver=docker
   ```

2. **Включение Ingress-контроллера**:
   ```bash
   minikube addons enable ingress
   ```

3. **Проверка кластера**:
   ```bash
   kubectl cluster-info
   kubectl get nodes
   ```

**Возможные сетевые ошибки**:
- **Minikube не может разрешить DNS**:
  - **Симптом**: Ошибка `Temporary Error: DNS resolution failed`.
  - **Решение**: Проверьте DNS (`cat /etc/resolv.conf`). Укажите публичные DNS:
    ```bash
    sudo sh -c 'echo "nameserver 8.8.8.8" >> /etc/resolv.conf'
    minikube start --driver=docker --dns 8.8.8.8
    ```
- **Ingress-контроллер не получает внешний IP**:
  - **Симптом**: `kubectl get ingress` показывает `<pending>` в ADDRESS.
  - **Решение**: Проверьте поды (`kubectl get pods -n ingress-nginx`). Перезапустите addon:
    ```bash
    minikube addons disable ingress
    minikube addons enable ingress
    ```
- **Сетевой плагин CNI не работает**:
  - **Симптом**: Поды в `Pending` с ошибкой `Failed to create pod sandbox`.
  - **Решение**: Проверьте CNI (`kubectl get pods -n kube-system | grep cni`). Переустановите:
    ```bash
    minikube start --network-plugin=cni --cni=flannel
    ```

## Шаг 3: Настройка приложения с микросервисами
1. **Создание Git-репозитория**:
   ```bash
   mkdir microservices-app
   cd microservices-app
   git init
   ```

2. **Frontend (React)**:
   ```bash
   mkdir frontend
   cd frontend
   npx create-react-app .
   ```
   Создайте `Dockerfile`:
   ```Dockerfile
   FROM node:16
   WORKDIR /app
   COPY package*.json ./
   RUN npm install
   COPY . .
   RUN npm run build
   CMD ["npm", "start"]
   ```

3. **Backend (Node.js)**:
   ```bash
   mkdir ../backend
   cd ../backend
   npm init -y
   npm install express mongodb
   ```
   Создайте `index.js`:
   ```javascript
   const express = require('express');
   const { MongoClient } = require('mongodb');
   const app = express();
   const port = 3000;

   app.use(express.json());

   const url = 'mongodb://mongodb:27017';
   const dbName = 'mydb';

   app.get('/data', async (req, res) => {
     let client;
     try {
       client = await MongoClient.connect(url);
       const db = client.db(dbName);
       const data = await db.collection('items').find().toArray();
       res.json(data);
     } catch (err) {
       res.status(500).send(err.message);
     } finally {
       if (client) client.close();
     }
   });

   app.listen(port, () => console.log(`Backend running on port ${port}`));
   ```
   Создайте `Dockerfile`:
   ```Dockerfile
   FROM node:16
   WORKDIR /app
   COPY package*.json ./
   RUN npm install
   COPY . .
   CMD ["node", "index.js"]
   ```

4. **База данных (MongoDB)**:
   Развертывается через Kubernetes.

**Возможные сетевые ошибки**:
- **Backend не может разрешить имя сервиса MongoDB**:
  - **Симптом**: Ошибка `MongoServerSelectionError: getaddrinfo ENOTFOUND mongodb`.
  - **Решение**: Проверьте сервис (`kubectl get svc mongodb`). Убедитесь, что CoreDNS работает:
    ```bash
    kubectl get pods -n kube-system | grep coredns
    kubectl delete pod -n kube-system -l k8s-app=kube-dns
    ```
- **Frontend не может связаться с backend**:
  - **Симптом**: Ошибка CORS или `Connection refused`.
  - **Решение**: Проверьте сервис (`kubectl get svc backend`). Добавьте CORS:
    ```javascript
    app.use((req, res, next) => {
      res.header('Access-Control-Allow-Origin', '*');
      next();
    });
    ```

## Шаг 4: Создание манифестов Kubernetes
1. **MongoDB Deployment и Service**:
   ```yaml
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: mongodb
     namespace: default
   spec:
     replicas: 1
     selector:
       matchLabels:
         app: mongodb
     template:
       metadata:
         labels:
           app: mongodb
       spec:
         containers:
         - name: mongodb
           image: mongo:latest
           ports:
           - containerPort: 27017
   ---
   apiVersion: v1
   kind: Service
   metadata:
     name: mongodb
     namespace: default
   spec:
     selector:
       app: mongodb
     ports:
     - protocol: TCP
       port: 27017
       targetPort: 27017
   ```

2. **Backend Deployment и Service**:
   ```yaml
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: backend
     namespace: default
   spec:
     replicas: 2
     selector:
       matchLabels:
         app: backend
     template:
       metadata:
         labels:
           app: backend
       spec:
         containers:
         - name: backend
           image: my-backend:latest
           ports:
           - containerPort: 3000
   ---
   apiVersion: v1
   kind: Service
   metadata:
     name: backend
     namespace: default
   spec:
     selector:
       app: backend
     ports:
     - protocol: TCP
       port: 3000
       targetPort: 3000
   ```

3. **Frontend Deployment и Service**:
   ```yaml
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: frontend
     namespace: default
   spec:
     replicas: 2
     selector:
       matchLabels:
         app: frontend
     template:
       metadata:
         labels:
           app: frontend
       spec:
         containers:
         - name: frontend
           image: my-frontend:latest
           ports:
           - containerPort: 3000
   ---
   apiVersion: v1
   kind: Service
   metadata:
     name: frontend
     namespace: default
   spec:
     selector:
       app: frontend
     ports:
     - protocol: TCP
       port: 3000
       targetPort: 3000
   ```

4. **Конфигурация Ingress**:
   ```yaml
   apiVersion: networking.k8s.io/v1
   kind: Ingress
   metadata:
     name: app-ingress
     namespace: default
   spec:
     rules:
     - http:
         paths:
         - path: /
           pathType: Prefix
           backend:
             service:
               name: frontend
               port:
                 number: 3000
   ```

**Возможные сетевые ошибки**:
- **Ingress не маршрутизирует трафик**:
  - **Симптом**: Ошибка `502 Bad Gateway`.
  - **Решение**: Проверьте сервис (`kubectl get svc frontend`) и поды (`kubectl get pods -l app=frontend`). Проверьте Ingress:
    ```bash
    kubectl get ingress app-ingress -o yaml
    ```
- **Службы не общаются из-за сетевых политик**:
  - **Симптом**: Backend не подключается к MongoDB.
  - **Решение**: Проверьте политики (`kubectl get networkpolicy`). Создайте:
    ```yaml
    apiVersion: networking.k8s.io/v1
    kind: NetworkPolicy
    metadata:
      name: allow-backend-to-mongodb
      namespace: default
    spec:
      podSelector:
        matchLabels:
          app: mongodb
      policyTypes:
      - Ingress
      ingress:
      - from:
        - podSelector:
            matchLabels:
              app: backend
        ports:
        - protocol: TCP
          port: 27017
    ```
    ```bash
    kubectl apply -f network-policy.yaml
    ```
- **Проблемы с балансировкой нагрузки**:
  - **Симптом**: Запросы к `frontend` возвращают ошибки.
  - **Решение**: Проверьте тип сервиса (`kubectl get svc frontend -o yaml`). Проверьте состояние:
    ```bash
    kubectl describe svc frontend
    ```

## Шаг 5: Настройка CI/CD пайплайна с Jenkins
1. **Запуск Jenkins**:
   ```bash
   systemctl start jenkins
   ```

2. **Конфигурация Jenkins**:
   - Установите плагины: Docker, Git, Kubernetes.
   - Настройте доступ к Docker:
     ```bash
     sudo usermod -aG docker jenkins
     systemctl restart jenkins
     ```

3. **Создание Jenkinsfile**:
   ```groovy
   pipeline {
       agent any
       stages {
           stage('Build') {
               steps {
                   dir('frontend') {
                       sh 'docker build -t my-frontend:latest .'
                   }
                   dir('backend') {
                       sh 'docker build -t my-backend:latest .'
                   }
               }
           }
           stage('Push') {
               steps {
                   sh 'minikube cache add my-frontend:latest'
                   sh 'minikube cache add my-backend:latest'
               }
           }
           stage('Deploy') {
               steps {
                   sh 'kubectl apply -f k8s/mongodb.yaml'
                   sh 'kubectl apply -f k8s/backend.yaml'
                   sh 'kubectl apply -f k8s/frontend.yaml'
                   sh 'kubectl apply -f k8s/ingress.yaml'
               }
           }
       }
   }
   ```

4. **Настройка задачи Jenkins**:
   - Создайте Pipeline задачу.
   - Укажите путь к репозиторию.
   - Укажите `Jenkinsfile`.

**Возможные сетевые ошибки**:
- **Jenkins не может подключиться к Kubernetes API**:
  - **Симптом**: Ошибка `Failed to connect to Kubernetes API`.
  - **Решение**: Скопируйте `~/.kube/config`:
    ```bash
    sudo mkdir -p /var/lib/jenkins/.kube
    sudo cp ~/.kube/config /var/lib/jenkins/.kube/
    sudo chown jenkins:jenkins /var/lib/jenkins/.kube/config
    ```
    Проверьте:
    ```bash
    sudo -u jenkins kubectl get nodes
    ```
- **Сетевые задержки в пайплайне**:
  - **Симптом**: Этап `Deploy` зависает.
  - **Решение**: Проверьте нагрузку (`iftop`). Увеличьте ресурсы:
    ```bash
    minikube stop
    minikube start --memory=4096 --cpus=2
    ```

## Шаг 6: Настройка мониторинга с Prometheus и Grafana
1. **Установка Prometheus**:
   ```bash
   helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
   helm install prometheus prometheus-community/prometheus
   ```

2. **Установка Grafana**:
   ```bash
   helm repo add grafana https://grafana.github.io/helm-charts
   helm install grafana grafana/grafana
   ```

3. **Доступ к Grafana**:
   ```bash
   kubectl get secret --namespace default grafana -o jsonpath="{.data.admin-password}" | base64 --decode
   kubectl port-forward svc/grafana 3000:80
   ```

4. **Конфигурация Grafana**:
   - Добавьте Prometheus (`http://prometheus-server`).
   - Импортируйте дашборд (ID 6417).

**Возможные сетевые ошибки**:
- **Prometheus не может обнаружить сервисы**:
  - **Симптом**: Пустые таргеты в Prometheus.
  - **Решение**: Проверьте discovery:
    ```bash
    kubectl describe configmap prometheus-server
    ```
    Добавьте аннотации:
    ```yaml
    metadata:
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "3000"
    ```
    ```bash
    kubectl edit svc backend
    ```
- **Grafana не может подключиться к Prometheus**:
  - **Симптом**: Ошибка `Connection refused`.
  - **Решение**: Проверьте сервис:
    ```bash
    kubectl get svc prometheus-server
    kubectl port-forward svc/prometheus-server 9090:80
    ```

## Шаг 7: Тестирование приложения
1. **Доступ к приложению**:
   ```bash
   minikube ip
   curl http://<minikube-ip>
   ```

2. **Проверка мониторинга**:
   Проверьте метрики в Grafana.

**Возможные сетевые ошибки**:
- **Minikube IP недоступен извне**:
  - **Симптом**: `Connection timed out`.
  - **Решение**: Проверьте интерфейс:
    ```bash
    minikube ip
    ip a
    minikube tunnel
    ```
- **Трафик блокируется фаерволом**:
  - **Симптом**: Ошибка `Connection refused`.
  - **Решение**: Разрешите порт:
    ```bash
    sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT
    ```

## Рекомендации
- **Офлайн-доступ**: Сохраните образы и манифесты:
  ```bash
  docker save -o my-frontend.tar my-frontend:latest
  tar -czf k8s_manifests.tar.gz k8s/
  ```
- **Тестирование**: Практикуйтесь с ограничением времени.
- **Шпаргалки**: Используйте Приложения D и E:
  ```bash
  grep kubectl cheatsheet_k8s.txt
  ```
- **Сетевые тесты**: Используйте:
  ```bash
  nslookup mongodb.default.svc.cluster.local
  ```


---

### Следующие шаги
Я добавил сетевые ошибки для Задачи 2, сосредоточившись на проблемах с DNS, Ingress, CNI, сетевыми политиками и фаерволом. Хотите:
1. Выведите решение для Задачи 3 с аналогичным уровнем детализации?
2. Добавить еще больше сетевых ошибок или других аспектов для Задачи 2?
3. Сгенерировать полный справочник с решениями в Markdown или PDF?

Уточните, например: "Выведи решение для Задачи 3" или "Добавь больше ошибок для CI/CD в Задаче 2".