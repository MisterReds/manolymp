# Часть I. Сетевые технологии

## `ip` — Управление сетевыми интерфейсами

**Команды:**

```bash
ip addr add 192.168.1.1/24 dev eth0  # Назначить IP-адрес интерфейсу eth0
ip link set eth0 up                  # Активировать интерфейс
ip route add 10.0.0.0/24 via 192.168.1.254  # Добавить маршрут
```

**Описание:**

- `ip addr`: Управляет IP-адресами и подсетями.
- `ip link`: Включает или выключает сетевые интерфейсы.
- `ip route`: Настраивает таблицу маршрутизации.

**Примеры:**

- `ip addr show` — Отображает все назначенные IP-адреса.
- `ip route show table all` — Показывает все маршруты, включая специальные таблицы.
- `ip -s link` — Выводит статистику по интерфейсам (пакеты, ошибки).

**Рекомендации для олимпиады:**

- Перед настройкой сети проверяйте состояние интерфейсов (`ip link`).
- Используйте `ipcalc` для расчета подсетей, если доступен, или заранее подготовьте таблицу подсетей.

**Частые ошибки:**

- Интерфейс не активирован → Используйте `ip link set <interface> up`.
- Неправильная маска подсети → Проверьте с помощью `ip addr` или `ipcalc`.

**Таблица подсетей (пример):**

|Маска|Диапазон IP|Количество хостов|
|---|---|---|
|/24|192.168.1.0-255|254|
|/30|192.168.1.0-3|2|

---

## `ifconfig` — Устаревшая команда для настройки сети

**Команды:**

```bash
ifconfig eth0 192.168.1.1 netmask 255.255.255.0  # Назначить IP-адрес
ifconfig eth0 up                                 # Активировать интерфейс
```

**Описание:**

- Упрощенный инструмент для назначения IP-адресов и управления интерфейсами.

**Рекомендации для олимпиады:**

- Полезен в старых системах (например, Astra Linux), где `ip` может отсутствовать.
- Используйте как резервный вариант.

**Частые ошибки:**

- Отсутствует `netmask` → Указывайте явно, иначе подсеть может быть неверной.
- Интерфейс не активирован → Добавьте `up`.

---

## `ping` — Диагностика доступности хоста

**Команды:**

```bash
ping 8.8.8.8          # Проверка связи с внешним сервером
ping -c 3 192.168.1.1 # Отправить 3 пакета
```

**Описание:**

- Проверяет доступность узла через ICMP-запросы.

**Примеры:**

- `ping -i 0.5 192.168.1.1` — Установить интервал между пакетами (0.5 сек).
- `ping -s 1000 8.8.8.8` — Изменить размер пакета для тестирования MTU.

**Рекомендации для олимпиады:**

- Используйте для быстрой проверки связности между контейнерами и ВМ.
- Ограничивайте запросы с помощью `-c` для экономии времени.

**Частые ошибки:**

- ICMP заблокирован → Проверьте фаервол (`iptables -L`).
- Нет маршрута → Убедитесь в правильности таблицы маршрутизации (`ip route`).

---

## `traceroute` / `mtr` — Диагностика маршрута

**Команды:**

```bash
traceroute 8.8.8.8         # Показать путь до цели
mtr --report 8.8.8.8       # Собрать статистику маршрута
```

**Описание:**

- `traceroute`: Отображает путь пакетов до цели.
- `mtr`: Комбинирует `ping` и `traceroute` с анализом задержек.

**Рекомендации для олимпиады:**

- Используйте `mtr --report` для быстрого анализа проблем с маршрутизацией.
- Увеличивайте TTL (`-m`) при таймаутах.

**Частые ошибки:**

- Требуются права root → Запускайте с `sudo`.
- Таймаут → Проверьте маршруты и фаервол.

---

## `tcpdump` — Анализ сетевого трафика

**Команды:**

```bash
tcpdump -i eth0 port 80 -w capture.pcap  # Записать HTTP-трафик
tcpdump -i eth0 host 192.168.1.10        # Фильтр по хосту
```

**Описание:**

- Инструмент для захвата и анализа сетевых пакетов.

**Примеры:**

- `tcpdump -r capture.pcap` — Чтение сохраненного дампа.
- `tcpdump -n -i eth0 tcp port 22` — Фильтр по SSH без разрешения имен.

**Рекомендации для олимпиады:**

- Сохраняйте трафик в файл для анализа в Wireshark, если доступен.
- Фильтруйте данные, чтобы избежать перегрузки вывода.

**Частые ошибки:**

- Нет прав → Используйте `sudo`.
- Слишком много данных → Добавьте фильтры (например, `port 80`).

# Часть II. Виртуализация и контейнеры

## `docker` — Управление контейнерами

**Команды:**

```bash
docker build -t my_app .                        # Собрать образ из Dockerfile
docker run -d -p 80:80 my_app                   # Запустить контейнер с пробросом порта 80
docker network create --driver bridge my_net     # Создать виртуальную сеть
docker volume create my_volume                   # Создать том для данных
```

**Описание:**

- `docker build`: Создает образ на основе Dockerfile.
- `docker run -d`: Запускает контейнер в фоновом режиме.
- `-p <host_port>:<container_port>`: Пробрасывает порты между хостом и контейнером.
- `docker network create`: Создает изолированные сети для взаимодействия контейнеров.
- `docker volume create`: Обеспечивает персистентное хранение данных.

**Примеры:**

- `docker ps -a` — Показать все контейнеры, включая остановленные.
- `docker exec -it my_container bash` — Войти в работающий контейнер.
- `docker save -o my_app.tar my_app` — Сохранить образ для офлайн-использования.
- `docker inspect my_container` — Показать конфигурацию контейнера (сеть, порты).

**Рекомендации для олимпиады:**

- Подготовьте `Dockerfile` для типичных приложений (например, Nginx, Python) заранее.
- Тестируйте образы локально, так как доступ к интернету на финале ограничен.
- Используйте `docker save`/`docker load` для работы без реестра (например, Docker Hub).
- Проверяйте связность контейнеров в одной сети с помощью `docker network inspect`.

**Частые ошибки:**

- Порт занят → Проверьте с помощью `netstat -tuln` и выберите другой порт.
- Контейнер завершился → Используйте `docker logs my_container` для диагностики.
- Образ не найден → Убедитесь, что образ сохранен локально (`docker images`).

**Таблица полезных команд Docker:**

|Команда|Описание|
|---|---|
|`docker ps`|Список активных контейнеров|
|`docker images`|Список локальных образов|
|`docker rm <container>`|Удалить контейнер|
|`docker rmi <image>`|Удалить образ|

---

## `docker-compose` — Оркестрация контейнеров

**Пример `docker-compose.yml`:**

```yaml
version: '3.8'
services:
  web:
    image: nginx:latest
    ports:
      - "80:80"
    volumes:
      - ./html:/usr/share/nginx/html
    networks:
      - my_net
  db:
    image: postgres:latest
    environment:
      POSTGRES_PASSWORD: example
    volumes:
      - db_data:/var/lib/postgresql/data
    networks:
      - my_net
networks:
  my_net:
    driver: bridge
volumes:
  db_data:
```

**Команды:**

```bash
docker-compose up -d          # Запустить сервисы в фоновом режиме
docker-compose down           # Остановить и удалить сервисы
docker-compose ps             # Показать статус сервисов
```

**Описание:**

- `docker-compose.yml`: YAML-файл для определения сервисов, сетей и томов.
- Поддерживает зависимости, автоматический запуск и управление многоконтейнерными приложениями.

**Примеры:**

- `docker-compose build` — Собрать образы из локальных Dockerfile.
- `docker-compose logs web` — Просмотреть логи сервиса `web`.

**Рекомендации для олимпиады:**

- Подготовьте шаблоны `docker-compose.yml` для типичных сценариев (веб + база данных).
- Используйте для автоматизации развертывания нескольких контейнеров.
- Тестируйте YAML-файлы заранее с помощью `docker-compose config` для проверки синтаксиса.

**Частые ошибки:**

- Неправильный формат YAML → Используйте `yamllint` или онлайн-валидаторы.
- Сервис не стартует → Проверьте логи (`docker-compose logs`) и переменные окружения.

---

## `kubectl` — Управление кластерами Kubernetes

**Команды:**

```bash
kubectl get pods                        # Список подов
kubectl apply -f deployment.yaml        # Применить манифест
kubectl describe pod my-pod             # Показать детали пода
kubectl logs my-pod                     # Просмотреть логи
kubectl exec -it my-pod -- /bin/bash    # Войти в контейнер
```

**Описание:**

- Основной CLI-инструмент для управления объектами Kubernetes (подами, сервисами, деплоями).

**Примеры:**

- `kubectl get services` — Показать список сервисов.
- `kubectl delete pod my-pod` — Удалить под.
- `kubectl get nodes` — Показать ноды кластера.

**Рекомендации для олимпиады:**

- Подготовьте шаблоны манифестов для `Deployment`, `Service`, `ConfigMap`.
- Используйте `kubectl apply` для быстрого развертывания.
- Храните образы локально, так как доступ к реестрам (например, Docker Hub) может быть ограничен.

**Частые ошибки:**

- Под не запустился → Проверьте с помощью `kubectl describe pod`.
- Сервис недоступен → Убедитесь, что тип сервиса (`ClusterIP`, `NodePort`) соответствует заданию.

**Пример `deployment.yaml`:**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-app
        image: my_app:latest
        ports:
        - containerPort: 80
```

---

## `VirtualBox` — Управление виртуальными машинами

**Команды:**

```bash
VBoxManage list vms                     # Список виртуальных машин
VBoxManage startvm "MyVM" --type headless  # Запуск ВМ в фоновом режиме
VBoxManage controlvm "MyVM" poweroff    # Выключить ВМ
```

**Описание:**

- CLI-инструмент для управления виртуальными машинами в VirtualBox.

**Примеры:**

- `VBoxManage showvminfo "MyVM"` — Показать конфигурацию ВМ.
- `VBoxManage modifyvm "MyVM" --memory 2048` — Установить 2 ГБ RAM для ВМ.

**Рекомендации для олимпиады:**

- Используйте для создания тестовых ВМ с предустановленными ОС (Debian, Astra Linux).
- Настройте сетевые адаптеры (NAT, Bridge) заранее.

**Частые ошибки:**

- ВМ не найдена → Проверьте список (`VBoxManage list vms`).
- Проблемы с сетью → Убедитесь, что режим сети соответствует заданию.

---

## `virsh` — Управление KVM/QEMU

**Команды:**

```bash
virsh list --all               # Показать все ВМ
virsh start my_vm              # Запустить ВМ
virsh shutdown my_vm           # Выключить ВМ
virsh console my_vm            # Подключиться к консоли
```

**Описание:**

- Инструмент для управления виртуальными машинами на базе KVM/QEMU.

**Примеры:**

- `virsh define my_vm.xml` — Создать ВМ из XML-конфигурации.
- `virsh net-list` — Показать доступные сети.

**Рекомендации для олимпиады:**

- Используйте для настройки ВМ в системах, где VirtualBox недоступен.
- Подготовьте XML-шаблоны для быстрого создания ВМ.

**Частые ошибки:**

- ВМ не найдена → Проверьте список (`virsh list --all`).
- Консоль не отвечает → Перезапустите ВМ (`virsh reboot`).

**Пример сети KVM:**

```bash
virsh net-create network.xml  # Создать сеть из XML
```

```xml
<network>
  <name>my_net</name>
  <bridge name="virbr1"/>
  <forward mode="nat"/>
  <ip address="192.168.100.1" netmask="255.255.255.0">
    <dhcp>
      <range start="192.168.100.2" end="192.168.100.254"/>
    </dhcp>
  </ip>
</network>
```

---

## Рекомендации по применению в условиях олимпиады

- **Тестирование**: Протестируйте Docker и Kubernetes на локальной машине (например, с Minikube) перед финалом.
- **Офлайн-ресурсы**: Сохраните образы (`docker save`) и документацию (Docker, Kubernetes) локально, так как интернет ограничен.
- **Автоматизация**: Используйте `docker-compose` для быстрого развертывания многоконтейнерных приложений.
- **Диагностика**: При проблемах с контейнерами используйте `docker logs` и `kubectl describe` для отладки.

# Часть III. Автоматизация

## `ansible-playbook` — Выполнение сценариев Ansible

**Пример `playbook.yml`:**

```yaml
- name: Установить и настроить NGINX
  hosts: webservers
  become: yes
  tasks:
    - name: Обновить список пакетов
      apt:
        update_cache: yes
    - name: Установить NGINX
      apt:
        name: nginx
        state: present
    - name: Запустить и включить NGINX
      service:
        name: nginx
        state: started
        enabled: yes
    - name: Копировать конфигурацию NGINX
      copy:
        src: ./nginx.conf
        dest: /etc/nginx/nginx.conf
      notify: Перезапустить NGINX
  handlers:
    - name: Перезапустить NGINX
      service:
        name: nginx
        state: restarted
```

**Пример `inventory.ini`:**

```ini
[webservers]
192.168.1.10
192.168.1.11 ansible_user=admin ansible_ssh_private_key_file=~/.ssh/id_rsa
```

**Команды:**

```bash
ansible-playbook -i inventory.ini playbook.yml  # Запустить playbook
ansible-playbook -i inventory.ini playbook.yml --check  # Проверить без применения
ansible all -i inventory.ini -m ping  # Проверить доступность хостов
```

**Описание:**

- `hosts`: Указывает целевые хосты для выполнения задач.
- `become: yes`: Выполняет задачи с правами root.
- `apt`, `service`, `copy`: Модули для управления пакетами, службами и файлами.
- `handlers`: Определяют действия, выполняемые при уведомлениях (например, перезапуск сервиса).

**Примеры:**

- `ansible-playbook playbook.yml --limit 192.168.1.10` — Выполнить playbook только для одного хоста.
- `ansible all -m shell -a "uptime"` — Выполнить команду `uptime` на всех хостах.

**Рекомендации для олимпиады:**

- Подготовьте шаблоны playbook для типовых задач: установка веб-сервера, настройка DNS, управление пользователями.
- Используйте `ansible-galaxy` для загрузки готовых ролей (например, `geerlingguy.nginx`) в офлайн-режиме.
- Тестируйте playbook локально с `--check` для экономии времени.
- Настройте SSH-ключи заранее (`ssh-copy-id`) для бесшовного доступа.

**Частые ошибки:**

- Неправильный формат YAML → Проверяйте с помощью `yamllint`.
- SSH-доступ не работает → Убедитесь, что ключи добавлены в `ssh-agent` (`ssh-add`).
- Отсутствуют права root → Добавьте `become: yes` или проверьте привилегии.

**Таблица модулей Ansible:**

|Модуль|Описание|
|---|---|
|`apt`|Управление пакетами в Debian/Ubuntu|
|`yum`|Управление пакетами в RHEL/CentOS|
|`service`|Управление системными службами|
|`copy`|Копирование файлов на хост|

---

## `terraform` — Развертывание инфраструктуры как код

**Пример `main.tf`:**

```hcl
provider "docker" {
  host = "unix:///var/run/docker.sock"
}

resource "docker_image" "nginx" {
  name         = "nginx:latest"
  keep_locally = true
}

resource "docker_container" "nginx" {
  image = docker_image.nginx.name
  name  = "my_nginx"
  ports {
    internal = 80
    external = 8080
  }
}
```

**Команды:**

```bash
terraform init       # Инициализировать провайдеры
terraform plan       # Показать план изменений
terraform apply      # Применить конфигурацию
terraform destroy    # Удалить ресурсы
```

**Описание:**

- `provider`: Определяет инфраструктурный провайдер (например, Docker, AWS, GCP).
- `resource`: Описывает создаваемые объекты (контейнеры, ВМ, сети).
- `init`, `plan`, `apply`: Этапы жизненного цикла Terraform.

**Примеры:**

- `terraform state list` — Показать созданные ресурсы.
- `terraform output` — Вывести определенные выходные параметры.

**Рекомендации для олимпиады:**

- Подготовьте шаблоны для Docker и Kubernetes (например, создание подов или сервисов).
- Сохраняйте состояние (`terraform.tfstate`) локально для офлайн-работы.
- Используйте модули для повторного использования кода (например, модуль для Nginx).

**Частые ошибки:**

- Ошибка провайдера → Убедитесь, что сервис доступен (например, Docker работает).
- Конфликты ресурсов → Проверьте вывод `terraform plan`.
- Неправильный синтаксис HCL → Используйте `terraform validate`.

---

## Shell-скрипты — Автоматизация системных задач

**Пример скрипта для проверки портов:**

```bash
#!/bin/bash
# check_ports.sh
set -e  # Остановить выполнение при ошибке
for ip in 192.168.1.{1..10}; do
  echo "Проверка $ip..."
  for port in 22 80 443; do
    nc -zv $ip $port &>/dev/null && echo "$ip:$port - открыт" || echo "$ip:$port - закрыт"
  done
done
```

**Команды:**

```bash
chmod +x check_ports.sh  # Дать права на выполнение
./check_ports.sh         # Запустить скрипт
```

**Описание:**

- Использует циклы (`for`, `while`) и утилиты (`grep`, `awk`, `sed`) для автоматизации задач.
- Подходит для диагностики, настройки сети и резервного копирования.

**Примеры:**

- `watch -n 1 ./check_ports.sh` — Запускать скрипт каждую секунду.
- `echo "export PATH=$PATH:/usr/local/bin" >> ~/.bashrc` — Добавить путь в переменную окружения.

**Рекомендации для олимпиады:**

- Подготовьте скрипты для типичных задач: проверка сети, запуск сервисов, бэкап конфигураций.
- Добавьте обработку ошибок (`set -e`, `trap`) для надежности.
- Проверяйте синтаксис с помощью `shellcheck`.

**Частые ошибки:**

- Нет прав на выполнение → Используйте `chmod +x script.sh`.
- Синтаксические ошибки → Проверяйте с `shellcheck`.
- Неправильный путь → Убедитесь, что файлы доступны (`ls -l`).

**Пример обработки ошибок:**

```bash
#!/bin/bash
set -e
trap 'echo "Ошибка в строке $LINENO"; exit 1' ERR
command_that_might_fail
```

---

## Рекомендации по применению в условиях олимпиады

- **Тестирование**: Протестируйте Ansible playbooks и Terraform конфигурации локально перед финалом.
- **Офлайн-ресурсы**: Сохраните роли Ansible (`ansible-galaxy`) и провайдеры Terraform локально.
- **Автоматизация**: Используйте Shell-скрипты для быстрой диагностики и повторяющихся задач.
- **Диагностика**: При ошибках используйте `ansible-playbook --check` и `terraform plan` для проверки.

# Часть IV. Безопасность

## `iptables` — Настройка сетевого фаервола

**Команды:**

```bash
iptables -A INPUT -p tcp --dport 22 -j ACCEPT  # Разрешить SSH (порт 22)
iptables -A INPUT -p icmp -j ACCEPT            # Разрешить ICMP (ping)
iptables -A INPUT -j DROP                      # Запретить все остальное
iptables -L -v -n                              # Показать правила с номерами
iptables -F                                    # Очистить все правила
```

**Описание:**

- `iptables`: Управляет правилами фильтрации сетевых пакетов.
- `-A`: Добавляет правило в цепочку (`INPUT`, `OUTPUT`, `FORWARD`).
- `-p`: Указывает протокол (`tcp`, `udp`, `icmp`).
- `-j`: Определяет действие (`ACCEPT`, `DROP`, `REJECT`).

**Примеры:**

- `iptables -A INPUT -s 192.168.1.0/24 -p tcp --dport 80 -j ACCEPT` — Разрешить HTTP для подсети.
- `iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE` — Настроить NAT для маршрутизации.
- `iptables -D INPUT 3` — Удалить правило под номером 3 (`iptables -L --line-numbers`).

**Рекомендации для олимпиады:**

- Сохраняйте правила с помощью `iptables-save > rules.v4` для быстрого восстановления (`iptables-restore < rules.v4`).
- Начинайте с очистки правил (`iptables -F`) во избежание конфликтов.
- Проверяйте правила перед применением с помощью `iptables -L -v`.

**Частые ошибки:**

- Правила не применяются → Убедитесь, что они сохранены (`iptables-save`).
- Блокировка SSH → Добавьте правило для порта 22 перед `DROP`.
- Неправильный порядок правил → Используйте `iptables -L --line-numbers` для проверки.

**Таблица цепочек iptables:**

|Цепочка|Описание|
|---|---|
|`INPUT`|Входящий трафик на сервер|
|`OUTPUT`|Исходящий трафик с сервера|
|`FORWARD`|Трафик, проходящий через сервер|
|`NAT`|Правила для трансляции адресов|

---

## SELinux — Управление обязательным контролем доступа

**Команды:**

```bash
sestatus                             # Проверить статус SELinux
setenforce 0                         # Переключить в Permissive (разрешительный режим)
setenforce 1                         # Переключить в Enforcing (строгий режим)
semanage port -a -t http_port_t -p tcp 8080  # Разрешить порт 8080 для HTTP
restorecon -v /var/www/html          # Восстановить контекст SELinux
```

**Описание:**

- SELinux управляет доступом на основе контекстов безопасности (пользователь, роль, тип).
- Режимы: `Enforcing` (блокирует нарушения), `Permissive` (логирует, но не блокирует), `Disabled`.

**Примеры:**

- `getsebool -a | grep http` — Показать boolean-значения для HTTP.
- `setsebool -P httpd_can_network_connect on` — Разрешить Nginx подключаться к сети.
- `ls -Z /var/www` — Показать SELinux-контексты файлов.

**Рекомендации для олимпиады:**

- Проверяйте статус SELinux (`sestatus`) перед началом задач.
- Используйте `Permissive` для тестирования, но возвращайте `Enforcing` для финальной настройки.
- Логируйте нарушения SELinux с помощью `audit2why` (`/var/log/audit/audit.log`).

**Частые ошибки:**

- Сервис не работает → Проверьте SELinux-логи (`ausearch -m avc`).
- Неправильный контекст → Используйте `chcon` или `restorecon` для исправления.
- Отсутствует `semanage` → Убедитесь, что установлен пакет `policycoreutils-python`.

---

## SSH — Настройка безопасного удаленного доступа

**Команды:**

```bash
ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa  # Создать SSH-ключи
ssh-copy-id user@192.168.1.10               # Скопировать ключ на сервер
ssh user@192.168.1.10                       # Подключиться к серверу
```

**Описание:**

- SSH обеспечивает безопасный доступ к удаленным системам.
- Конфигурация хранится в `/etc/ssh/sshd_config`.

**Примеры:**

- `ssh -i ~/.ssh/id_rsa user@192.168.1.10` — Подключиться с указанием ключа.
- `scp file.txt user@192.168.1.10:/home/user/` — Скопировать файл на сервер.
- `sudo systemctl restart sshd` — Перезапустить SSH-сервер после изменения конфигурации.

**Пример изменения `/etc/ssh/sshd_config`:**

```bash
Port 2222
PermitRootLogin no
PasswordAuthentication no
```

**Рекомендации для олимпиады:**

- Настройте SSH-ключи заранее для всех хостов (`ssh-copy-id`).
- Измените порт SSH (например, на 2222) для защиты от сканирования.
- Ограничьте доступ по IP в `iptables` или `sshd_config` (`AllowUsers user@192.168.1.*`).

**Частые ошибки:**

- Ошибка подключения → Проверьте фаервол (`iptables -L`) и порт в `sshd_config`.
- Ключ не работает → Убедитесь, что права на `~/.ssh/authorized_keys` — `600` (`chmod 600`).
- Сервис не запущен → Проверьте статус (`systemctl status sshd`).

---

## Рекомендации по применению в условиях олимпиады

- **Тестирование**: Проверьте правила `iptables` и SELinux на тестовой ВМ перед финалом.
- **Офлайн-ресурсы**: Сохраните конфигурации `iptables` и `sshd_config` локально.
- **Безопасность**: Ограничьте доступ SSH и используйте SELinux в `Enforcing` для финальных решений.
- **Диагностика**: Используйте `audit2why` для SELinux и `iptables -L -v` для фаервола.

# Часть V. CI/CD и системы контроля версий

## `git` — Система контроля версий

**Команды:**

```bash
git init                            # Инициализировать новый репозиторий
git clone git@192.168.1.10:/repo.git  # Клонировать репозиторий
git add .                           # Добавить все изменения в индекс
git commit -m "Initial commit"      # Создать коммит
git push origin main                # Отправить изменения в удаленный репозиторий
```

**Описание:**

- `git init`: Создает локальный репозиторий.
- `git clone`: Копируются данные из удаленного репозитория.
- `git add`, `git commit`: Фиксируют изменения в истории.
- `git push`, `git pull`: Синхронизируют локальный и удаленный репозитории.

**Примеры:**

- `git branch feature` — Создать ветку `feature`.
- `git checkout feature` — Переключиться на ветку `feature`.
- `git merge feature` — Слить ветку `feature` в текущую.
- `git log --oneline` — Показать краткую историю коммитов.

**Рекомендации для олимпиады:**

- Настройте SSH-ключи для Git (`ssh-keygen`, `git config`) заранее.
- Подготовьте `.gitignore` для исключения временных файлов (например, `*.log`, `node_modules`).
- Используйте локальный сервер Git (например, GitLab) для офлайн-работы.
- Практикуйтесь в разрешении конфликтов слияния (`git merge`, `git mergetool`).

**Частые ошибки:**

- Конфликт слияния → Отредактируйте конфликтующие файлы и выполните `git add`, затем `git commit`.
- Неправильная ветка → Проверьте текущую ветку (`git branch`) и переключитесь (`git checkout`).
- Проблемы с доступом → Убедитесь, что SSH-ключи добавлены (`ssh-add`).

**Пример `.gitignore`:**

```
*.log
node_modules/
.env
```

---

## `Jenkins` — Автоматизация CI/CD

**Пример `Jenkinsfile`:**

```groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                sh 'docker build -t my_app .'
            }
        }
        stage('Test') {
            steps {
                sh 'docker run my_app npm test'
            }
        }
        stage('Deploy') {
            steps {
                sh 'docker push my_app:latest'
            }
        }
    }
    post {
        always {
            sh 'docker system prune -f'
        }
    }
}
```

**Команды:**

```bash
systemctl start jenkins          # Запустить Jenkins
systemctl enable jenkins         # Включить автозапуск
curl http://192.168.1.10:8080    # Проверить доступ к Jenkins
```

**Описание:**

- `Jenkinsfile`: Определяет CI/CD-пайплайн с этапами (`Build`, `Test`, `Deploy`).
- `agent any`: Выполняет пайплайн на любом доступном агенте.
- `stages`, `steps`: Описывают последовательность задач.

**Примеры:**

- Установить плагин Docker: В UI Jenkins добавить `Docker` и `Docker Pipeline`.
- Настроить вебхук: В GitLab/GitHub указать URL Jenkins для автозапуска пайплайна.

**Рекомендации для олимпиады:**

- Подготовьте шаблон `Jenkinsfile` для типичных задач (сборка Docker-образов, деплой).
- Сохраните плагины и конфигурации Jenkins локально для офлайн-установки.
- Настройте Jenkins на локальной ВМ с Docker для тестирования.
- Используйте credentials в Jenkins для безопасного хранения паролей/ключей.

**Частые ошибки:**

- Пайплайн не запускается → Проверьте логи (`Manage Jenkins > System Log`).
- Ошибка Docker → Убедитесь, что Jenkins имеет доступ к Docker (`usermod -aG docker jenkins`).
- Проблемы с доступом → Проверьте фаервол (`iptables -L`) и порт (по умолчанию 8080).

---

## `GitLab CI` — Альтернатива для CI/CD

**Пример `.gitlab-ci.yml`:**

```yaml
stages:
  - build
  - test
  - deploy

build_job:
  stage: build
  script:
    - docker build -t my_app .
    - docker save -o my_app.tar my_app

test_job:
  stage: test
  script:
    - docker load -i my_app.tar
    - docker run my_app npm test

deploy_job:
  stage: deploy
  script:
    - docker load -i my_app.tar
    - docker run -d -p 80:80 my_app
```

**Команды:**

```bash
gitlab-runner register  # Зарегистрировать runner
gitlab-runner start     # Запустить runner
curl http://192.168.1.10  # Проверить доступ к GitLab
```

**Описание:**

- `.gitlab-ci.yml`: Определяет пайплайн с этапами и задачами.
- `stages`: Задает порядок выполнения (например, `build`, `test`, `deploy`).
- `script`: Список команд для каждого задания.

**Примеры:**

- `docker login -u user -p pass` — Авторизация в реестре для `docker push`.
- `artifacts: paths: [my_app.tar]` — Сохранить артефакты между этапами.

**Рекомендации для олимпиады:**

- Настройте локальный GitLab и runner для офлайн-работы.
- Подготовьте `.gitlab-ci.yml` для типичных задач (сборка, тестирование, деплой).
- Используйте Docker-in-Docker для выполнения заданий в контейнерах.
- Тестируйте пайплайны локально с помощью `gitlab-runner exec docker build_job`.

**Частые ошибки:**

- Runner не работает → Проверьте статус (`gitlab-runner status`) и конфигурацию (`/etc/gitlab-runner/config.toml`).
- Ошибка доступа к Docker → Добавьте runner в группу Docker (`usermod -aG docker gitlab-runner`).
- Артефакты не сохраняются → Убедитесь, что указаны `artifacts` в `.gitlab-ci.yml`.

---

## Рекомендации по применению в условиях олимпиады

- **Тестирование**: Протестируйте Git-репозитории и CI/CD-пайплайны на локальной ВМ.
- **Офлайн-ресурсы**: Сохраните Docker-образы, плагины Jenkins и конфигурации GitLab локально.
- **Автоматизация**: Используйте `Jenkinsfile` или `.gitlab-ci.yml` для автоматизации развертывания приложений.
- **Диагностика**: Проверяйте логи Jenkins (`System Log`) и GitLab CI (`Pipelines > Jobs`) при ошибках.

# Часть VI. Оркестрация и Kubernetes

## `kubectl` — Управление кластерами Kubernetes

**Команды:**

```bash
kubectl get pods -n default                # Список подов в пространстве имен default
kubectl apply -f deployment.yaml           # Применить манифест
kubectl describe pod my-pod                # Показать детали пода
kubectl logs my-pod                        # Просмотреть логи пода
kubectl exec -it my-pod -- /bin/bash       # Войти в контейнер пода
```

**Описание:**

- `kubectl`: CLI-инструмент для управления Kubernetes-объектами (подами, сервисами, деплоями).
- `-n`: Указывает пространство имен (namespace).
- `apply`: Создает или обновляет ресурсы из YAML/JSON-файлов.
- `describe`, `logs`: Используются для диагностики.

**Примеры:**

- `kubectl get services -o wide` — Показать сервисы с подробной информацией.
- `kubectl scale deployment my-app --replicas=3` — Изменить количество реплик.
- `kubectl delete pod my-pod` — Удалить под.
- `kubectl get nodes` — Показать ноды кластера.

**Пример `deployment.yaml`:**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
  namespace: default
spec:
  replicas: 2
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-app
        image: nginx:latest
        ports:
        - containerPort: 80
```

**Пример `service.yaml`:**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
  namespace: default
spec:
  selector:
    app: my-app
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
  type: ClusterIP
```

**Рекомендации для олимпиады:**

- Подготовьте шаблоны манифестов для `Deployment`, `Service`, `Ingress`, и `ConfigMap`.
- Используйте `kubectl apply` для быстрого развертывания и `kubectl delete` для очистки.
- Храните образы локально (`docker save/load`), так как доступ к реестрам (например, Docker Hub) может быть ограничен.
- Тестируйте команды на локальном кластере (например, Minikube или kind).

**Частые ошибки:**

- Под не запустился → Проверьте с помощью `kubectl describe pod` и `kubectl logs`.
- Сервис недоступен → Убедитесь, что селектор сервиса совпадает с метками пода (`matchLabels`).
- Ошибка namespace → Укажите правильное пространство имен (`-n`).

**Таблица типов сервисов Kubernetes:**

|Тип|Описание|
|---|---|
|`ClusterIP`|Внутренний доступ внутри кластера|
|`NodePort`|Доступ через порт ноды (30000-32767)|
|`LoadBalancer`|Внешний доступ через балансировщик|
|`ExternalName`|Проксирование внешнего имени|

---

## `helm` — Менеджер пакетов для Kubernetes

**Команды:**

```bash
helm repo add bitnami https://charts.bitnami.com/bitnami  # Добавить репозиторий
helm install my-release bitnami/nginx                      # Установить чарт
helm list                                                 # Список установленных релизов
helm upgrade my-release bitnami/nginx                     # Обновить релиз
helm uninstall my-release                                  # Удалить релиз
```

**Описание:**

- Helm упрощает установку и управление приложениями в Kubernetes с помощью чартов.
- Чарт: Набор YAML-файлов и шаблонов для развертывания приложения.
- `values.yaml`: Файл для настройки параметров чарта.

**Пример `values.yaml` для Nginx:**

```yaml
replicaCount: 2
image:
  repository: nginx
  tag: latest
service:
  type: ClusterIP
  port: 80
```

**Примеры:**

- `helm create my-chart` — Создать новый чарт.
- `helm lint my-chart` — Проверить чарт на ошибки.
- `helm package my-chart` — Упаковать чарт для офлайн-использования.

**Рекомендации для олимпиады:**

- Сохраните популярные чарты (например, Nginx, PostgreSQL) локально для офлайн-установки.
- Подготовьте кастомные `values.yaml` для типичных приложений.
- Тестируйте чарты локально с помощью `helm install --dry-run` для проверки.
- Используйте Helm для быстрого развертывания сложных приложений (например, WordPress).

**Частые ошибки:**

- Чарт не устанавливается → Проверьте `helm lint` и наличие зависимостей.
- Неправильные значения → Убедитесь, что `values.yaml` соответствует чарту.
- Ошибка репозитория → Добавьте репозиторий (`helm repo add`) или используйте локальный чарт.

---

## Основные концепции Kubernetes

**Pod**:

- Минимальная единица в Kubernetes, содержащая один или несколько контейнеров.
- Пример: `kubectl run my-pod --image=nginx --restart=Never`.

**Deployment**:

- Управляет подами, обеспечивая масштабирование и обновления.
- Пример: `kubectl create deployment my-app --image=nginx`.

**Service**:

- Обеспечивает сетевой доступ к подам.
- Пример: `kubectl expose deployment my-app --port=80 --type=NodePort`.

**ConfigMap/Secret**:

- Хранят конфигурации и чувствительные данные.
- Пример ConfigMap:
    
    ```yaml
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: my-config
    data:
      database_url: "mysql://db:3306"
    ```
    

**Рекомендации для олимпиады:**

- Используйте `ConfigMap` для хранения переменных окружения.
- Шифруйте секреты с помощью `kubectl create secret`.
- Настройте `HorizontalPodAutoscaler` для автоматического масштабирования, если требуется.

**Частые ошибки:**

- Неправильные метки → Убедитесь, что метки в `selector` совпадают с подами.
- Ограничения ресурсов → Укажите `requests` и `limits` в манифесте для стабильности.

**Пример указания ресурсов:**

```yaml
spec:
  containers:
  - name: my-app
    image: nginx
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
```

---

## Рекомендации по применению в условиях олимпиады

- **Тестирование**: Протестируйте Kubernetes на локальном кластере (Minikube, kind) перед финалом.
- **Офлайн-ресурсы**: Сохраните образы (`docker save`), чарты Helm и манифесты локально.
- **Автоматизация**: Используйте Helm для быстрого развертывания сложных приложений.
- **Диагностика**: При ошибках используйте `kubectl describe`, `kubectl logs`, и `kubectl events`.

# Часть VII. Мониторинг и диагностика

## `Prometheus` — Система мониторинга и алертинга

**Пример `prometheus.yml`:**

```yaml
global:
  scrape_interval: 15s
scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']
  - job_name: 'node'
    static_configs:
      - targets: ['192.168.1.10:9100']
```

**Команды:**

```bash
prometheus --config.file=prometheus.yml  # Запустить Prometheus
curl http://192.168.1.10:9090            # Проверить доступ к веб-интерфейсу
systemctl start prometheus               # Запустить как службу
```

**Описание:**

- Prometheus собирает метрики по HTTP, используя pull-модель.
- `scrape_configs`: Определяет цели для сбора метрик.
- Веб-интерфейс (по умолчанию порт 9090) позволяет выполнять PromQL-запросы.

**Примеры:**

- PromQL-запрос: `rate(http_requests_total[5m])` — Скорость HTTP-запросов за 5 минут.
- `curl http://192.168.1.10:9100/metrics` — Проверить метрики Node Exporter.
- `promtool check config prometheus.yml` — Проверить конфигурацию.

**Рекомендации для олимпиады:**

- Установите Node Exporter на узлы для сбора системных метрик (CPU, память, диск).
- Подготовьте шаблон `prometheus.yml` для типичных сценариев (мониторинг серверов, контейнеров).
- Сохраните образы Prometheus и Node Exporter локально (`docker save`) для офлайн-использования.
- Используйте PromQL для быстрого анализа (например, `up` для проверки доступности).

**Частые ошибки:**

- Цели недоступны → Проверьте `targets` в `prometheus.yml` и фаервол (`iptables -L`).
- Ошибка конфигурации → Используйте `promtool check config`.
- Высокая нагрузка → Уменьшите `scrape_interval` (например, до 30s).

---

## `Grafana` — Визуализация метрик

**Команды:**

```bash
grafana-server --config=/etc/grafana/grafana.ini  # Запустить Grafana
systemctl start grafana-server                    # Запустить как службу
curl http://192.168.1.10:3000                     # Проверить доступ (логин: admin, пароль: admin)
```

**Описание:**

- Grafana создает дашборды для визуализации метрик из источников, таких как Prometheus.
- Поддерживает кастомные дашборды и алерты.

**Примеры:**

- Добавить источник данных: В UI Grafana выбрать Prometheus и указать URL (например, `http://192.168.1.10:9090`).
- Импортировать дашборд: Использовать ID дашборда (например, 1860 для Node Exporter) из Grafana Labs.
- Создать панель: Использовать PromQL, например, `node_cpu_seconds_total`.

**Рекомендации для олимпиады:**

- Сохраните дашборды локально (JSON-файлы) для офлайн-импорта.
- Подготовьте дашборды для мониторинга CPU, памяти, сети и контейнеров.
- Настройте Grafana с Prometheus в Docker для быстрого развертывания.
- Используйте `grafana-cli plugins install` для офлайн-установки плагинов.

**Частые ошибки:**

- Источник данных не работает → Проверьте URL Prometheus и сетевую доступность (`curl`).
- Дашборд пустой → Убедитесь, что метрики собираются (`prometheus.yml`).
- Проблемы с доступом → Проверьте фаервол и порт (по умолчанию 3000).

**Пример Docker Compose для Prometheus и Grafana:**

```yaml
version: '3.8'
services:
  prometheus:
    image: prom/prometheus
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "9090:9090"
  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
```

---

## `top` / `htop` — Мониторинг процессов

**Команды:**

```bash
top                           # Запустить top
htop                          # Запустить htop (если установлен)
```

**Описание:**

- `top`: Отображает процессы в реальном времени (CPU, память, PID).
- `htop`: Более удобная альтернатива с цветным интерфейсом и фильтрацией.

**Примеры:**

- В `htop` нажмите `F4` и введите `nginx` для фильтрации процессов.
- В `top` нажмите `1` для отображения всех CPU-ядер.
- `kill -9 <PID>` — Завершить процесс по PID из `top`/`htop`.

**Рекомендации для олимпиады:**

- Используйте `htop` для быстрого анализа (установите заранее: `apt install htop`).
- Проверяйте процессы с высоким потреблением CPU/памяти.
- Сортируйте по `%CPU` или `%MEM` для выявления проблем.

**Частые ошибки:**

- `htop` не установлен → Установите (`apt install htop`) или используйте `top`.
- Процесс не завершается → Убедитесь, что используете правильный PID.

---

## `netstat` / `ss` — Анализ сетевых соединений

**Команды:**

```bash
netstat -tuln                     # Показать открытые порты
ss -tuln                          # Альтернатива netstat
netstat -nap | grep :80           # Показать процессы на порту 80
ss -nap | grep :80                # То же для ss
```

**Описание:**

- `netstat` и `ss` показывают сетевые соединения, порты и связанные процессы.
- `-t`: TCP, `-u`: UDP, `-l`: слушающие порты, `-n`: числовые адреса.

**Примеры:**

- `netstat -tunap` — Показать все активные соединения и процессы.
- `ss -t -a` — Показать все TCP-соединения.

**Рекомендации для олимпиады:**

- Используйте `ss` вместо `netstat` для большей скорости (если доступно).
- Проверяйте, какие порты открыты, перед настройкой сервисов.
- Ищите подозрительные соединения для диагностики безопасности.

**Частые ошибки:**

- Порт занят → Найдите процесс (`netstat -nap`) и завершите его (`kill`).
- Команда не найдена → Установите `net-tools` для `netstat` или используйте `ss`.

---

## `journalctl` — Анализ системных логов

**Команды:**

```bash
journalctl -u nginx.service        # Логи сервиса Nginx
journalctl -xe                    # Показать последние ошибки
journalctl --since "2025-05-21"    # Логи с указанной даты
journalctl -f                     # Следить за логами в реальном времени
```

**Описание:**

- `journalctl`: Инструмент для просмотра логов systemd.
- `-u`: Фильтрация по сервису, `-f`: Режим следования.

**Примеры:**

- `journalctl -u docker.service -b` — Логи Docker с момента загрузки.
- `journalctl | grep error` — Найти все сообщения с "error".

**Рекомендации для олимпиады:**

- Используйте `journalctl -xe` для быстрого поиска ошибок.
- Фильтруйте по сервисам (`-u`) для диагностики конкретных приложений.
- Сохраняйте логи (`journalctl > logs.txt`) для анализа.

**Частые ошибки:**

- Логи пустые → Проверьте, работает ли сервис (`systemctl status`).
- Слишком много данных → Ограничьте вывод (`--since`, `-n 100`).

---

## Рекомендации по применению в условиях олимпиады

- **Тестирование**: Протестируйте Prometheus и Grafana на локальной ВМ перед финалом.
- **Офлайн-ресурсы**: Сохраните образы Prometheus, Grafana и дашборды локально.
- **Мониторинг**: Настройте дашборды для CPU, памяти и сети для быстрого анализа.
- **Диагностика**: Используйте `journalctl`, `htop`, и `ss` для оперативного устранения неполадок.

# Часть VIII. Работа с документацией и офлайн-ресурсами

## `man` — Просмотр справочных страниц

**Команды:**

```bash
man ls                      # Открыть справочную страницу для команды ls
man 5 passwd               # Просмотреть страницу для файла /etc/passwd (раздел 5)
man -k keyword             # Поиск страниц по ключевому слову
```

**Описание:**

- `man` предоставляет доступ к справочным страницам, установленным локально.
- Страницы разделены по категориям (1 — команды, 5 — файлы конфигурации, 8 — системные команды).

**Примеры:**

- `man docker` — Просмотреть документацию для Docker.
- `man -k network` — Найти все страницы, связанные с сетью.
- `man iptables` — Изучить параметры команды `iptables`.

**Рекомендации для олимпиады:**

- Проверьте наличие man-страниц для ключевых инструментов (`docker`, `kubectl`, `ansible`) перед финалом.
- Установите дополнительные пакеты документации (например, `manpages-dev`, `docker.io-doc`) на тестовую ВМ.
- Используйте `man -k` для поиска альтернативных команд, если основная недоступна.

**Частые ошибки:**

- Страница отсутствует → Установите пакет (`apt install manpages`) или проверьте правильность команды.
- Слишком много информации → Используйте `/keyword` в `man` для поиска внутри страницы.
- Неправильный раздел → Укажите раздел явно (например, `man 5 passwd`).

**Таблица разделов man:**

|Раздел|Описание|
|---|---|
|1|Пользовательские команды|
|5|Форматы файлов и конфигурации|
|8|Системные команды и демоны|

---

## `info` — Доступ к расширенной документации

**Команды:**

```bash
info bash                  # Открыть документацию для Bash
info coreutils             # Просмотреть документацию для утилит coreutils
info -k keyword            # Поиск по ключевому слову
```

**Описание:**

- `info` предоставляет гипертекстовую документацию, более подробную, чем `man`.
- Поддерживает навигацию по узлам (разделам) с помощью клавиш (`n`, `p`, `u`).

**Примеры:**

- `info docker` — Просмотреть документацию для Docker (если установлена).
- `info -k iptables` — Найти информацию об `iptables`.
- `info` → Нажать `h` для справки по навигации.

**Рекомендации для олимпиады:**

- Установите пакеты `info` для ключевых инструментов (`apt install info`).
- Ознакомьтесь с навигацией заранее (например, `n` для следующего узла, `q` для выхода).
- Используйте `info` для сложных инструментов (например, `gcc`, `bash`), где `man` недостаточен.

**Частые ошибки:**

- Документация отсутствует → Установите пакет (`apt install texinfo`).
- Сложная навигация → Используйте `man` как альтернативу для простых команд.
- Неинтуитивный поиск → Практикуйтесь с `info -k` и клавишей `/` для поиска.

---

## Подготовка офлайн-ресурсов

**Стратегии:**

1. **Скачивание документации:**
    
    - Docker: `docker docs` (локальные HTML-копии с [https://docs.docker.com](https://docs.docker.com/)).
    - Kubernetes: `kubectl` и Helm документация ([https://kubernetes.io/docs/](https://kubernetes.io/docs/), [https://helm.sh/docs/](https://helm.sh/docs/)).
    - Ansible: Роли и модули (`ansible-galaxy collection download`).
    - Сохраните в `/usr/share/doc` или на USB-накопитель.
2. **Создание локального зеркала:**
    
    - Используйте `wget` для рекурсивного скачивания:
        
        ```bash
        wget -r -np -k https://docs.docker.com
        ```
        
    - Настройте локальный веб-сервер (Nginx) для доступа:
        
        ```bash
        docker run -d -p 8080:80 -v $(pwd)/docs:/usr/share/nginx/html nginx
        ```
        
3. **PDF и Markdown копии:**
    
    - Конвертируйте веб-страницы в PDF с помощью `wkhtmltopdf` или браузера.
    - Сохраните документацию в Markdown с помощью `pandoc`:
        
        ```bash
        pandoc -f html -t markdown https://docs.docker.com/get-started/ -o docker.md
        ```
        

**Команды для подготовки:**

```bash
apt install manpages manpages-dev texinfo  # Установить man и info страницы
docker pull nginx                         # Скачать образ Nginx для локального сервера
tar -czf docs.tar.gz /usr/share/doc       # Архивировать документацию
```

**Рекомендации для олимпиады:**

- Подготовьте USB-накопитель с документацией (PDF, HTML, man-страницы).
- Создайте локальный сервер документации с помощью Nginx или Python:
    
    ```bash
    python3 -m http.server 8000 --directory ./docs
    ```
    
- Храните команды в текстовом файле (например, `cheatsheet.txt`) для быстрого доступа.
- Тестируйте доступ к офлайн-ресурсам на ВМ без интернета.

**Частые ошибки:**

- Документация устарела → Проверьте версии инструментов (например, `docker --version`).
- Ограниченный доступ → Убедитесь, что файлы имеют права чтения (`chmod -R +r docs`).
- Недостаток места → Сжимайте архивы (`tar -czf`) и очищайте временные файлы (`rm -rf /tmp/*`).

**Пример структуры офлайн-ресурсов:**

```
offline-docs/
├── docker/
│   ├── index.html
│   ├── get-started.pdf
├── kubernetes/
│   ├── kubectl.md
│   ├── helm/
├── cheatsheet.txt
├── manpages.tar.gz
```

---

## Рекомендации по применению в условиях олимпиады

- **Тестирование**: Проверьте доступ к `man`, `info`, и офлайн-документации на тестовой ВМ.
- **Офлайн-ресурсы**: Сохраните документацию для Docker, Kubernetes, Ansible, и других инструментов локально.
- **Организация**: Создайте структурированную папку с документацией и используйте текстовый поиск (`grep`, `find`).
- **Диагностика**: Используйте `man -k` и `info -k` для быстрого поиска альтернативных решений.

# Часть IX. Практические сценарии

## Сценарий 1: Развертывание веб-приложения с помощью Docker и Nginx

**Задача**: Развернуть веб-приложение в контейнере Docker, настроить Nginx как прокси, обеспечить доступ через порт 80 и защитить сервер с помощью `iptables`.

**Шаги:**

1. **Создать Dockerfile для приложения:**
    
    ```Dockerfile
    FROM python:3.9-slim
    WORKDIR /app
    COPY . .
    RUN pip install flask
    CMD ["python", "app.py"]
    ```
    
    ```python
    # app.py
    from flask import Flask
    app = Flask(__name__)
    @app.route('/')
    def hello():
        return 'Hello, IT-Planeta 2025!'
    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=5000)
    ```
    
2. **Собрать и запустить контейнер:**
    
    ```bash
    docker build -t my_app .
    docker run -d --name my_app -p 5000:5000 my_app
    ```
    
3. **Настроить Nginx как прокси:**
    
    ```bash
    apt install nginx
    ```
    
    ```nginx
    # /etc/nginx/sites-available/my_app
    server {
        listen 80;
        server_name localhost;
        location / {
            proxy_pass http://127.0.0.1:5000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
    ```
    
    ```bash
    ln -s /etc/nginx/sites-available/my_app /etc/nginx/sites-enabled/
    nginx -t
    systemctl restart nginx
    ```
    
4. **Настроить `iptables` для безопасности:**
    
    ```bash
    iptables -A INPUT -p tcp --dport 80 -j ACCEPT
    iptables -A INPUT -p tcp --dport 22 -j ACCEPT
    iptables -A INPUT -j DROP
    iptables-save > /etc/iptables/rules.v4
    ```
    
5. **Проверить доступ:**
    
    ```bash
    curl http://localhost
    # Ожидаемый вывод: Hello, IT-Planeta 2025!
    ```
    

**Рекомендации для олимпиады:**

- Подготовьте Dockerfile и Nginx-конфигурацию заранее.
- Сохраните образ (`docker save -o my_app.tar my_app`) для офлайн-использования.
- Проверяйте порты (`netstat -tuln`) перед запуском.
- Используйте `docker logs my_app` для диагностики.

**Частые ошибки:**

- Nginx не проксирует → Проверьте конфигурацию (`nginx -t`) и порт приложения.
- Порт заблокирован → Убедитесь, что `iptables` разрешает порт 80.
- Контейнер не запускается → Проверьте логи (`docker logs`).

---

## Сценарий 2: Настройка Kubernetes-кластера с мониторингом

**Задача**: Развернуть приложение в Kubernetes, настроить сервис для доступа, и добавить мониторинг с помощью Prometheus и Grafana.

**Шаги:**

1. **Создать манифесты для приложения:**
    
    ```yaml
    # deployment.yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: my-app
      namespace: default
    spec:
      replicas: 2
      selector:
        matchLabels:
          app: my-app
      template:
        metadata:
          labels:
            app: my-app
        spec:
          containers:
          - name: my-app
            image: nginx:latest
            ports:
            - containerPort: 80
    ```
    
    ```yaml
    # service.yaml
    apiVersion: v1
    kind: Service
    metadata:
      name: my-app-service
      namespace: default
    spec:
      selector:
        app: my-app
      ports:
      - protocol: TCP
        port: 80
        targetPort: 80
      type: NodePort
    ```
    
2. **Применить манифесты:**
    
    ```bash
    kubectl apply -f deployment.yaml
    kubectl apply -f service.yaml
    kubectl get pods
    kubectl get svc
    ```
    
3. **Развернуть Prometheus и Grafana с помощью Helm:**
    
    ```bash
    helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
    helm install prometheus prometheus-community/prometheus
    helm repo add grafana https://grafana.github.io/helm-charts
    helm install grafana grafana/grafana
    ```
    
4. **Настроить доступ к Grafana:**
    
    ```bash
    kubectl get svc grafana
    # Найти NodePort (например, 32000)
    curl http://192.168.1.10:32000
    # Логин: admin, пароль: получить через `kubectl get secret grafana -o jsonpath="{.data.admin-password}" | base64 --decode`
    ```
    
5. **Добавить дашборд в Grafana:**
    
    - В UI Grafana добавить Prometheus как источник данных (`http://prometheus-server`).
    - Импортировать дашборд (ID 1860 для Node Exporter) или создать панель с запросом `rate(http_requests_total[5m])`.

**Рекомендации для олимпиады:**

- Сохраните Helm-чарты и образы локально (`helm pull`, `docker save`).
- Подготовьте манифесты для `Deployment` и `Service` заранее.
- Проверяйте статус подов (`kubectl describe pod`) при проблемах.
- Используйте `kubectl port-forward` для локального доступа к сервисам:
    
    ```bash
    kubectl port-forward svc/grafana 3000:80
    ```
    

**Частые ошибки:**

- Под не запускается → Проверьте образ (`kubectl describe pod`).
- Сервис недоступен → Убедитесь, что `selector` совпадает с метками пода.
- Helm-чарт не работает → Проверьте зависимости (`helm dependency update`).

---

## Сценарий 3: Автоматизация настройки сервера с Ansible

**Задача**: Настроить веб-сервер (Nginx) и SSH-доступ на удаленном сервере с помощью Ansible, обеспечив безопасность.

**Шаги:**

1. **Создать inventory-файл:**
    
    ```ini
    # inventory.ini
    [webservers]
    192.168.1.10 ansible_user=admin ansible_ssh_private_key_file=~/.ssh/id_rsa
    ```
    
2. **Создать playbook:**
    
    ```yaml
    # playbook.yml
    - name: Настроить веб-сервер и SSH
      hosts: webservers
      become: yes
      tasks:
        - name: Установить Nginx
          apt:
            name: nginx
            state: present
            update_cache: yes
        - name: Запустить Nginx
          service:
            name: nginx
            state: started
            enabled: yes
        - name: Настроить SSH
          lineinfile:
            path: /etc/ssh/sshd_config
            regexp: '^PermitRootLogin'
            line: 'PermitRootLogin no'
          notify: Перезапустить SSH
        - name: Открыть порт 80 в iptables
          iptables:
            chain: INPUT
            protocol: tcp
            destination_port: 80
            jump: ACCEPT
      handlers:
        - name: Перезапустить SSH
          service:
            name: sshd
            state: restarted
    ```
    
3. **Запустить playbook:**
    
    ```bash
    ansible-playbook -i inventory.ini playbook.yml --check
    ansible-playbook -i inventory.ini playbook.yml
    ```
    
4. **Проверить результат:**
    
    ```bash
    curl http://192.168.1.10
    ssh admin@192.168.1.10
    ```
    

**Рекомендации для олимпиады:**

- Подготовьте шаблоны playbook для типичных задач (установка сервисов, настройка безопасности).
- Настройте SSH-ключи заранее (`ssh-copy-id`) для бесшовного доступа.
- Тестируйте playbook с `--check` для экономии времени.
- Сохраните роли Ansible локально (`ansible-galaxy`).

**Частые ошибки:**

- SSH не работает → Проверьте ключи (`ssh-add`) и конфигурацию (`/etc/ssh/sshd_config`).
- Playbook не выполняется → Проверяйте синтаксис (`yamllint playbook.yml`).
- iptables блокирует → Убедитесь, что порт 80 открыт (`iptables -L`).

---

## Рекомендации по применению в условиях олимпиады

- **Тестирование**: Протестируйте сценарии на локальной ВМ с Docker, Kubernetes, и Ansible.
- **Офлайн-ресурсы**: Сохраните образы, манифесты, и playbook’ы локально.
- **Автоматизация**: Используйте Ansible и Helm для быстрого развертывания.
- **Диагностика**: Применяйте `docker logs`, `kubectl describe`, и `journalctl` для устранения неполадок.
```


# Часть X. Советы по подготовке и тайм-менеджменту

## Подготовка к олимпиаде

**1. Создание тренировочной среды:**

- Настройте локальную виртуальную машину (VM) с Ubuntu/CentOS, Docker, Kubernetes (Minikube/kind), Ansible, и Prometheus.
- Пример команды для установки Minikube:
    
    ```bash
    curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
    sudo install minikube-linux-amd64 /usr/local/bin/minikube
    minikube start
    ```
    
- Реплицируйте сценарии из **Часть IX** (например, развертывание Nginx, настройка iptables).

**2. Офлайн-ресурсы:**

- Сохраните документацию, образы Docker, и Helm-чарты на USB-накопитель:
    
    ```bash
    docker save -o nginx.tar nginx:latest
    helm pull prometheus-community/prometheus --untar
    tar -czf docs.tar.gz ~/offline-docs
    ```
    
- Подготовьте шпаргалку (cheatsheet) с командами:
    
    ```bash
    echo -e "kubectl get pods\nansible-playbook -i inventory.ini playbook.yml" > cheatsheet.txt
    ```
    

**3. Практика типовых задач:**

- Развертывание веб-сервера (Docker/Nginx).
- Настройка CI/CD (Jenkins/GitLab CI).
- Мониторинг с Prometheus/Grafana.
- Автоматизация с Ansible/Terraform.
- Пример: Настройте Kubernetes-кластер и разверните приложение за 20 минут.

**4. Изучение документации:**

- Ознакомьтесь с `man` и `info` для ключевых инструментов (`docker`, `kubectl`, `iptables`).
- Практикуйтесь с `man -k` и `info -k` для быстрого поиска:
    
    ```bash
    man -k firewall
    info -k network
    ```
    

**Рекомендации:**

- Тренируйтесь в условиях ограниченного времени (например, 30 минут на развертывание Kubernetes).
- Создайте скрипт для быстрой настройки VM:
    
    ```bash
    # setup.sh
    #!/bin/bash
    apt update
    apt install -y docker.io nginx ansible
    systemctl enable --now docker
    ```
    
- Сохраняйте конфигурации в Git-репозитории для повторного использования:
    
    ```bash
    git init
    git add .
    git commit -m "Competition configs"
    ```
    

**Частые ошибки:**

- Неполная подготовка → Проверяйте наличие всех инструментов (`docker --version`, `kubectl version`).
- Устаревшие ресурсы → Убедитесь, что образы и документация соответствуют версиям в соревновании.
- Отсутствие офлайн-тестирования → Практикуйтесь без интернета.

---

## Тайм-менеджмент во время олимпиады

**1. Анализ задачи:**

- Прочитайте условие дважды, выделите ключевые требования (например, "развернуть Nginx", "настроить мониторинг").
- Разбейте задачу на шаги:
    - Установка инструментов.
    - Конфигурация сервисов.
    - Проверка и диагностика.
- Пример: Для развертывания веб-приложения:
    1. Установить Docker (5 мин).
    2. Настроить Nginx (10 мин).
    3. Проверить доступ (5 мин).

**2. Приоритизация:**

- Выполняйте задачи с наибольшим количеством баллов или меньшей сложностью первыми.
- Если задача зависает (например, под Kubernetes не запускается), переключитесь на другую и вернитесь позже.
- Используйте таймер (например, `watch -n 60 date`) для контроля времени.

**3. Автоматизация рутинных задач:**

- Используйте Ansible для повторяющихся настроек:
    
    ```bash
    ansible-playbook -i inventory.ini playbook.yml
    ```
    
- Применяйте Helm для быстрого развертывания:
    
    ```bash
    helm install my-release bitnami/nginx
    ```
    

**4. Диагностика и отладка:**

- Проверяйте логи сразу при ошибках:
    
    ```bash
    docker logs my_app
    kubectl describe pod my-pod
    journalctl -u nginx.service
    ```
    
- Используйте `htop` и `ss` для анализа нагрузки и сетевых проблем:
    
    ```bash
    htop
    ss -tuln
    ```
    

**Рекомендации:**

- Делите время на блоки: 70% на выполнение, 20% на проверку, 10% на документацию.
- Сохраняйте промежуточные результаты (например, `iptables-save > rules.v4`).
- Если задача не решается за 20 минут, запишите проблему и переходите к следующей.

**Частые ошибки:**

- Потеря времени на отладку → Ограничивайте время на диагностику (например, 5 минут).
- Игнорирование проверки → Всегда тестируйте результат (`curl`, `kubectl get pods`).
- Паника при ошибках → Делайте паузу и используйте `journalctl -xe` для анализа.

---

## Управление стрессом

**1. Подготовка к давлению:**

- Практикуйтесь в условиях, имитирующих соревнование (ограниченное время, отсутствие интернета).
- Выполняйте задачи под таймер:
    
    ```bash
    time ansible-playbook playbook.yml
    ```
    

**2. Техники во время соревнования:**

- Дыхательные упражнения: 4 секунды вдох, 4 секунды выдох (повторить 5 раз).
- Разделение задач на микро-шаги: Например, вместо "настроить Kubernetes" — "создать deployment.yaml", "применить манифест".
- Используйте шпаргалку для быстрого доступа к командам:
    
    ```bash
    cat cheatsheet.txt
    ```
    

**3. Работа с ошибками:**

- Записывайте ошибки в текстовый файл:
    
    ```bash
    echo "Pod failed: check image" >> errors.log
    ```
    
- Возвращайтесь к проблемам после выполнения простых задач.

**Рекомендации:**

- Начните с задач, в которых уверены, чтобы набрать баллы и успокоиться.
- Если застряли, переключитесь на другую задачу через 10 минут.
- Используйте `watch` для мониторинга прогресса:
    
    ```bash
    watch -n 10 kubectl get pods
    ```
    

**Частые ошибки:**

- Паника из-за нехватки времени → Фокусируйтесь на приоритетных задачах.
- Игнорирование отдыха → Делайте 1-минутные паузы каждые 30 минут.
- Отсутствие плана → Составьте список задач в начале (`echo "1. Nginx\n2. Kubernetes" > plan.txt`).

---

## Рекомендации по применению в условиях олимпиады

- **Тестирование**: Практикуйтесь с таймером, имитируя реальные ограничения.
- **Офлайн-ресурсы**: Держите шпаргалку и документацию под рукой (`man`, `info`, локальные PDF).
- **Тайм-менеджмент**: Распределяйте время между задачами (например, 30% на сложные, 70% на простые).
- **Стрессоустойчивость**: Используйте микро-шаги и дыхательные техники для сохранения спокойствия.



